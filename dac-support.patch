From 5bded9f807cf140d4cb043ab496d958418258b14 Mon Sep 17 00:00:00 2001
From: lostdeveloper <utahsbraincell@gmail.com>
Date: Fri, 21 Feb 2014 08:54:30 -0800
Subject: [PATCH] Dac support: on boot, hotplug, volume control for kitkat
 based on code by timur/jacknorris

---
 media/java/android/media/AudioFormat.java          |   69 +-
 media/java/android/media/AudioManager.java         | 2486 ++++++++++----------
 media/java/android/media/AudioService.java         |   32 +-
 media/java/android/media/AudioTrack.java           | 1011 ++++----
 .../com/android/server/WiredAccessoryManager.java  |  136 +-
 5 files changed, 1936 insertions(+), 1798 deletions(-)

diff --git a/media/java/android/media/AudioFormat.java b/media/java/android/media/AudioFormat.java
index 49f498e..bb6f129 100644
--- a/media/java/android/media/AudioFormat.java
+++ b/media/java/android/media/AudioFormat.java
@@ -1,27 +1,27 @@
 /*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2008 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 package android.media;
 
 /**
- * The AudioFormat class is used to access a number of audio format and
- * channel configuration constants. They are for instance used
- * in {@link AudioTrack} and {@link AudioRecord}.
- * 
- */
+* The AudioFormat class is used to access a number of audio format and
+* channel configuration constants. They are for instance used
+* in {@link AudioTrack} and {@link AudioRecord}.
+*
+*/
 public class AudioFormat {
     
     //---------------------------------------------------------
@@ -37,18 +37,19 @@ public class AudioFormat {
     /** Audio data format: PCM 8 bit per sample. Not guaranteed to be supported by devices. */
     public static final int ENCODING_PCM_8BIT = 3;
 
+    public static final int ENCODING_PCM_24BIT = 4;
     /** Invalid audio channel configuration */
-    /** @deprecated use CHANNEL_INVALID instead  */
-    @Deprecated    public static final int CHANNEL_CONFIGURATION_INVALID   = 0;
+    /** @deprecated use CHANNEL_INVALID instead */
+    @Deprecated public static final int CHANNEL_CONFIGURATION_INVALID = 0;
     /** Default audio channel configuration */
-    /** @deprecated use CHANNEL_OUT_DEFAULT or CHANNEL_IN_DEFAULT instead  */
-    @Deprecated    public static final int CHANNEL_CONFIGURATION_DEFAULT   = 1;
+    /** @deprecated use CHANNEL_OUT_DEFAULT or CHANNEL_IN_DEFAULT instead */
+    @Deprecated public static final int CHANNEL_CONFIGURATION_DEFAULT = 1;
     /** Mono audio configuration */
-    /** @deprecated use CHANNEL_OUT_MONO or CHANNEL_IN_MONO instead  */
-    @Deprecated    public static final int CHANNEL_CONFIGURATION_MONO      = 2;
+    /** @deprecated use CHANNEL_OUT_MONO or CHANNEL_IN_MONO instead */
+    @Deprecated public static final int CHANNEL_CONFIGURATION_MONO = 2;
     /** Stereo (2 channel) audio configuration */
-    /** @deprecated use CHANNEL_OUT_STEREO or CHANNEL_IN_STEREO instead  */
-    @Deprecated    public static final int CHANNEL_CONFIGURATION_STEREO    = 3;
+    /** @deprecated use CHANNEL_OUT_STEREO or CHANNEL_IN_STEREO instead */
+    @Deprecated public static final int CHANNEL_CONFIGURATION_STEREO = 3;
 
     /** Invalid audio channel mask */
     public static final int CHANNEL_INVALID = 0;
@@ -56,7 +57,7 @@ public class AudioFormat {
     public static final int CHANNEL_OUT_DEFAULT = 1;
 
     // Channel mask definitions below are translated to the native values defined in
-    //  in /system/core/include/system/audio.h in the JNI code of AudioTrack
+    // in /system/core/include/system/audio.h in the JNI code of AudioTrack
     public static final int CHANNEL_OUT_FRONT_LEFT = 0x4;
     public static final int CHANNEL_OUT_FRONT_RIGHT = 0x8;
     public static final int CHANNEL_OUT_FRONT_CENTER = 0x10;
@@ -67,23 +68,23 @@ public class AudioFormat {
     public static final int CHANNEL_OUT_FRONT_RIGHT_OF_CENTER = 0x200;
     public static final int CHANNEL_OUT_BACK_CENTER = 0x400;
     /** @hide */
-    public static final int CHANNEL_OUT_SIDE_LEFT =         0x800;
+    public static final int CHANNEL_OUT_SIDE_LEFT = 0x800;
     /** @hide */
-    public static final int CHANNEL_OUT_SIDE_RIGHT =       0x1000;
+    public static final int CHANNEL_OUT_SIDE_RIGHT = 0x1000;
     /** @hide */
-    public static final int CHANNEL_OUT_TOP_CENTER =       0x2000;
+    public static final int CHANNEL_OUT_TOP_CENTER = 0x2000;
     /** @hide */
-    public static final int CHANNEL_OUT_TOP_FRONT_LEFT =   0x4000;
+    public static final int CHANNEL_OUT_TOP_FRONT_LEFT = 0x4000;
     /** @hide */
     public static final int CHANNEL_OUT_TOP_FRONT_CENTER = 0x8000;
     /** @hide */
     public static final int CHANNEL_OUT_TOP_FRONT_RIGHT = 0x10000;
     /** @hide */
-    public static final int CHANNEL_OUT_TOP_BACK_LEFT =   0x20000;
+    public static final int CHANNEL_OUT_TOP_BACK_LEFT = 0x20000;
     /** @hide */
     public static final int CHANNEL_OUT_TOP_BACK_CENTER = 0x40000;
     /** @hide */
-    public static final int CHANNEL_OUT_TOP_BACK_RIGHT =  0x80000;
+    public static final int CHANNEL_OUT_TOP_BACK_RIGHT = 0x80000;
 
     public static final int CHANNEL_OUT_MONO = CHANNEL_OUT_FRONT_LEFT;
     public static final int CHANNEL_OUT_STEREO = (CHANNEL_OUT_FRONT_LEFT | CHANNEL_OUT_FRONT_RIGHT);
diff --git a/media/java/android/media/AudioManager.java b/media/java/android/media/AudioManager.java
index c20720b..ef136f3 100644
--- a/media/java/android/media/AudioManager.java
+++ b/media/java/android/media/AudioManager.java
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2007 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 package android.media;
 
@@ -42,11 +42,11 @@ import android.view.VolumePanel;
 import java.util.HashMap;
 
 /**
- * AudioManager provides access to volume and ringer mode control.
- * <p>
- * Use <code>Context.getSystemService(Context.AUDIO_SERVICE)</code> to get
- * an instance of this class.
- */
+* AudioManager provides access to volume and ringer mode control.
+* <p>
+* Use <code>Context.getSystemService(Context.AUDIO_SERVICE)</code> to get
+* an instance of this class.
+*/
 public class AudioManager {
 
     private final Context mContext;
@@ -57,144 +57,144 @@ public class AudioManager {
     private static String TAG = "AudioManager";
 
     /**
-     * Broadcast intent, a hint for applications that audio is about to become
-     * 'noisy' due to a change in audio outputs. For example, this intent may
-     * be sent when a wired headset is unplugged, or when an A2DP audio
-     * sink is disconnected, and the audio system is about to automatically
-     * switch audio route to the speaker. Applications that are controlling
-     * audio streams may consider pausing, reducing volume or some other action
-     * on receipt of this intent so as not to surprise the user with audio
-     * from the speaker.
-     */
+* Broadcast intent, a hint for applications that audio is about to become
+* 'noisy' due to a change in audio outputs. For example, this intent may
+* be sent when a wired headset is unplugged, or when an A2DP audio
+* sink is disconnected, and the audio system is about to automatically
+* switch audio route to the speaker. Applications that are controlling
+* audio streams may consider pausing, reducing volume or some other action
+* on receipt of this intent so as not to surprise the user with audio
+* from the speaker.
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String ACTION_AUDIO_BECOMING_NOISY = "android.media.AUDIO_BECOMING_NOISY";
 
     /**
-     * Sticky broadcast intent action indicating that the ringer mode has
-     * changed. Includes the new ringer mode.
-     *
-     * @see #EXTRA_RINGER_MODE
-     */
+* Sticky broadcast intent action indicating that the ringer mode has
+* changed. Includes the new ringer mode.
+*
+* @see #EXTRA_RINGER_MODE
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String RINGER_MODE_CHANGED_ACTION = "android.media.RINGER_MODE_CHANGED";
 
     /**
-     * The new ringer mode.
-     *
-     * @see #RINGER_MODE_CHANGED_ACTION
-     * @see #RINGER_MODE_NORMAL
-     * @see #RINGER_MODE_SILENT
-     * @see #RINGER_MODE_VIBRATE
-     */
+* The new ringer mode.
+*
+* @see #RINGER_MODE_CHANGED_ACTION
+* @see #RINGER_MODE_NORMAL
+* @see #RINGER_MODE_SILENT
+* @see #RINGER_MODE_VIBRATE
+*/
     public static final String EXTRA_RINGER_MODE = "android.media.EXTRA_RINGER_MODE";
 
     /**
-     * Broadcast intent action indicating that the vibrate setting has
-     * changed. Includes the vibrate type and its new setting.
-     *
-     * @see #EXTRA_VIBRATE_TYPE
-     * @see #EXTRA_VIBRATE_SETTING
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
+* Broadcast intent action indicating that the vibrate setting has
+* changed. Includes the vibrate type and its new setting.
+*
+* @see #EXTRA_VIBRATE_TYPE
+* @see #EXTRA_VIBRATE_SETTING
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String VIBRATE_SETTING_CHANGED_ACTION =
         "android.media.VIBRATE_SETTING_CHANGED";
 
     /**
-     * @hide Broadcast intent when the volume for a particular stream type changes.
-     * Includes the stream, the new volume and previous volumes.
-     * Notes:
-     *  - for internal platform use only, do not make public,
-     *  - never used for "remote" volume changes
-     *
-     * @see #EXTRA_VOLUME_STREAM_TYPE
-     * @see #EXTRA_VOLUME_STREAM_VALUE
-     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE
-     */
+* @hide Broadcast intent when the volume for a particular stream type changes.
+* Includes the stream, the new volume and previous volumes.
+* Notes:
+* - for internal platform use only, do not make public,
+* - never used for "remote" volume changes
+*
+* @see #EXTRA_VOLUME_STREAM_TYPE
+* @see #EXTRA_VOLUME_STREAM_VALUE
+* @see #EXTRA_PREV_VOLUME_STREAM_VALUE
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String VOLUME_CHANGED_ACTION = "android.media.VOLUME_CHANGED_ACTION";
 
     /**
-     * @hide Broadcast intent when the master volume changes.
-     * Includes the new volume
-     *
-     * @see #EXTRA_MASTER_VOLUME_VALUE
-     * @see #EXTRA_PREV_MASTER_VOLUME_VALUE
-     */
+* @hide Broadcast intent when the master volume changes.
+* Includes the new volume
+*
+* @see #EXTRA_MASTER_VOLUME_VALUE
+* @see #EXTRA_PREV_MASTER_VOLUME_VALUE
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String MASTER_VOLUME_CHANGED_ACTION =
         "android.media.MASTER_VOLUME_CHANGED_ACTION";
 
     /**
-     * @hide Broadcast intent when the master mute state changes.
-     * Includes the the new volume
-     *
-     * @see #EXTRA_MASTER_VOLUME_MUTED
-     */
+* @hide Broadcast intent when the master mute state changes.
+* Includes the the new volume
+*
+* @see #EXTRA_MASTER_VOLUME_MUTED
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String MASTER_MUTE_CHANGED_ACTION =
         "android.media.MASTER_MUTE_CHANGED_ACTION";
 
     /**
-     * The new vibrate setting for a particular type.
-     *
-     * @see #VIBRATE_SETTING_CHANGED_ACTION
-     * @see #EXTRA_VIBRATE_TYPE
-     * @see #VIBRATE_SETTING_ON
-     * @see #VIBRATE_SETTING_OFF
-     * @see #VIBRATE_SETTING_ONLY_SILENT
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
+* The new vibrate setting for a particular type.
+*
+* @see #VIBRATE_SETTING_CHANGED_ACTION
+* @see #EXTRA_VIBRATE_TYPE
+* @see #VIBRATE_SETTING_ON
+* @see #VIBRATE_SETTING_OFF
+* @see #VIBRATE_SETTING_ONLY_SILENT
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+*/
     public static final String EXTRA_VIBRATE_SETTING = "android.media.EXTRA_VIBRATE_SETTING";
 
     /**
-     * The vibrate type whose setting has changed.
-     *
-     * @see #VIBRATE_SETTING_CHANGED_ACTION
-     * @see #VIBRATE_TYPE_NOTIFICATION
-     * @see #VIBRATE_TYPE_RINGER
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
+* The vibrate type whose setting has changed.
+*
+* @see #VIBRATE_SETTING_CHANGED_ACTION
+* @see #VIBRATE_TYPE_NOTIFICATION
+* @see #VIBRATE_TYPE_RINGER
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+*/
     public static final String EXTRA_VIBRATE_TYPE = "android.media.EXTRA_VIBRATE_TYPE";
 
     /**
-     * @hide The stream type for the volume changed intent.
-     */
+* @hide The stream type for the volume changed intent.
+*/
     public static final String EXTRA_VOLUME_STREAM_TYPE = "android.media.EXTRA_VOLUME_STREAM_TYPE";
 
     /**
-     * @hide The volume associated with the stream for the volume changed intent.
-     */
+* @hide The volume associated with the stream for the volume changed intent.
+*/
     public static final String EXTRA_VOLUME_STREAM_VALUE =
         "android.media.EXTRA_VOLUME_STREAM_VALUE";
 
     /**
-     * @hide The previous volume associated with the stream for the volume changed intent.
-     */
+* @hide The previous volume associated with the stream for the volume changed intent.
+*/
     public static final String EXTRA_PREV_VOLUME_STREAM_VALUE =
         "android.media.EXTRA_PREV_VOLUME_STREAM_VALUE";
 
     /**
-     * @hide The new master volume value for the master volume changed intent.
-     * Value is integer between 0 and 100 inclusive.
-     */
+* @hide The new master volume value for the master volume changed intent.
+* Value is integer between 0 and 100 inclusive.
+*/
     public static final String EXTRA_MASTER_VOLUME_VALUE =
         "android.media.EXTRA_MASTER_VOLUME_VALUE";
 
     /**
-     * @hide The previous master volume value for the master volume changed intent.
-     * Value is integer between 0 and 100 inclusive.
-     */
+* @hide The previous master volume value for the master volume changed intent.
+* Value is integer between 0 and 100 inclusive.
+*/
     public static final String EXTRA_PREV_MASTER_VOLUME_VALUE =
         "android.media.EXTRA_PREV_MASTER_VOLUME_VALUE";
 
     /**
-     * @hide The new master volume mute state for the master mute changed intent.
-     * Value is boolean
-     */
+* @hide The new master volume mute state for the master mute changed intent.
+* Value is boolean
+*/
     public static final String EXTRA_MASTER_VOLUME_MUTED =
         "android.media.EXTRA_MASTER_VOLUME_MUTED";
 
@@ -220,212 +220,212 @@ public class AudioManager {
     public static final int STREAM_TTS = AudioSystem.STREAM_TTS;
     /** Number of audio streams */
     /**
-     * @deprecated Use AudioSystem.getNumStreamTypes() instead
-     */
+* @deprecated Use AudioSystem.getNumStreamTypes() instead
+*/
     @Deprecated public static final int NUM_STREAMS = AudioSystem.NUM_STREAMS;
 
 
-    /**  @hide Default volume index values for audio streams */
+    /** @hide Default volume index values for audio streams */
     public static final int[] DEFAULT_STREAM_VOLUME = new int[] {
-        4,  // STREAM_VOICE_CALL
-        7,  // STREAM_SYSTEM
-        5,  // STREAM_RING
+        4, // STREAM_VOICE_CALL
+        7, // STREAM_SYSTEM
+        5, // STREAM_RING
         22, // STREAM_MUSIC
-        6,  // STREAM_ALARM
-        5,  // STREAM_NOTIFICATION
+        6, // STREAM_ALARM
+        5, // STREAM_NOTIFICATION
         14, // STREAM_BLUETOOTH_SCO
-        7,  // STREAM_SYSTEM_ENFORCED
+        7, // STREAM_SYSTEM_ENFORCED
         22, // STREAM_DTMF
-        22  // STREAM_TTS
+        22 // STREAM_TTS
     };
 
     /**
-     * Increase the ringer volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
+* Increase the ringer volume.
+*
+* @see #adjustVolume(int, int)
+* @see #adjustStreamVolume(int, int, int)
+*/
     public static final int ADJUST_RAISE = 1;
 
     /**
-     * Decrease the ringer volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
+* Decrease the ringer volume.
+*
+* @see #adjustVolume(int, int)
+* @see #adjustStreamVolume(int, int, int)
+*/
     public static final int ADJUST_LOWER = -1;
 
     /**
-     * Maintain the previous ringer volume. This may be useful when needing to
-     * show the volume toast without actually modifying the volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
+* Maintain the previous ringer volume. This may be useful when needing to
+* show the volume toast without actually modifying the volume.
+*
+* @see #adjustVolume(int, int)
+* @see #adjustStreamVolume(int, int, int)
+*/
     public static final int ADJUST_SAME = 0;
 
     // Flags should be powers of 2!
 
     /**
-     * Show a toast containing the current volume.
-     *
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     * @see #setRingerMode(int)
-     */
+* Show a toast containing the current volume.
+*
+* @see #adjustStreamVolume(int, int, int)
+* @see #adjustVolume(int, int)
+* @see #setStreamVolume(int, int, int)
+* @see #setRingerMode(int)
+*/
     public static final int FLAG_SHOW_UI = 1 << 0;
 
     /**
-     * Whether to include ringer modes as possible options when changing volume.
-     * For example, if true and volume level is 0 and the volume is adjusted
-     * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or
-     * vibrate mode.
-     * <p>
-     * By default this is on for the ring stream. If this flag is included,
-     * this behavior will be present regardless of the stream type being
-     * affected by the ringer mode.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
+* Whether to include ringer modes as possible options when changing volume.
+* For example, if true and volume level is 0 and the volume is adjusted
+* with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or
+* vibrate mode.
+* <p>
+* By default this is on for the ring stream. If this flag is included,
+* this behavior will be present regardless of the stream type being
+* affected by the ringer mode.
+*
+* @see #adjustVolume(int, int)
+* @see #adjustStreamVolume(int, int, int)
+*/
     public static final int FLAG_ALLOW_RINGER_MODES = 1 << 1;
 
     /**
-     * Whether to play a sound when changing the volume.
-     * <p>
-     * If this is given to {@link #adjustVolume(int, int)} or
-     * {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored
-     * in some cases (for example, the decided stream type is not
-     * {@link AudioManager#STREAM_RING}, or the volume is being adjusted
-     * downward).
-     *
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
+* Whether to play a sound when changing the volume.
+* <p>
+* If this is given to {@link #adjustVolume(int, int)} or
+* {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored
+* in some cases (for example, the decided stream type is not
+* {@link AudioManager#STREAM_RING}, or the volume is being adjusted
+* downward).
+*
+* @see #adjustStreamVolume(int, int, int)
+* @see #adjustVolume(int, int)
+* @see #setStreamVolume(int, int, int)
+*/
     public static final int FLAG_PLAY_SOUND = 1 << 2;
 
     /**
-     * Removes any sounds/vibrate that may be in the queue, or are playing (related to
-     * changing volume).
-     */
+* Removes any sounds/vibrate that may be in the queue, or are playing (related to
+* changing volume).
+*/
     public static final int FLAG_REMOVE_SOUND_AND_VIBRATE = 1 << 3;
 
     /**
-     * Whether to vibrate if going into the vibrate ringer mode.
-     */
+* Whether to vibrate if going into the vibrate ringer mode.
+*/
     public static final int FLAG_VIBRATE = 1 << 4;
 
     /**
-     * Indicates to VolumePanel that the volume slider should be disabled as user
-     * cannot change the stream volume
-     * @hide
-     */
+* Indicates to VolumePanel that the volume slider should be disabled as user
+* cannot change the stream volume
+* @hide
+*/
     public static final int FLAG_FIXED_VOLUME = 1 << 5;
 
     /**
-     * Indicates the volume set/adjust call is for Bluetooth absolute volume
-     * @hide
-     */
+* Indicates the volume set/adjust call is for Bluetooth absolute volume
+* @hide
+*/
     public static final int FLAG_BLUETOOTH_ABS_VOLUME = 1 << 6;
 
     /**
-     * Ringer mode that will be silent and will not vibrate. (This overrides the
-     * vibrate setting.)
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
+* Ringer mode that will be silent and will not vibrate. (This overrides the
+* vibrate setting.)
+*
+* @see #setRingerMode(int)
+* @see #getRingerMode()
+*/
     public static final int RINGER_MODE_SILENT = 0;
 
     /**
-     * Ringer mode that will be silent and will vibrate. (This will cause the
-     * phone ringer to always vibrate, but the notification vibrate to only
-     * vibrate if set.)
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
+* Ringer mode that will be silent and will vibrate. (This will cause the
+* phone ringer to always vibrate, but the notification vibrate to only
+* vibrate if set.)
+*
+* @see #setRingerMode(int)
+* @see #getRingerMode()
+*/
     public static final int RINGER_MODE_VIBRATE = 1;
 
     /**
-     * Ringer mode that may be audible and may vibrate. It will be audible if
-     * the volume before changing out of this mode was audible. It will vibrate
-     * if the vibrate setting is on.
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
+* Ringer mode that may be audible and may vibrate. It will be audible if
+* the volume before changing out of this mode was audible. It will vibrate
+* if the vibrate setting is on.
+*
+* @see #setRingerMode(int)
+* @see #getRingerMode()
+*/
     public static final int RINGER_MODE_NORMAL = 2;
 
     // maximum valid ringer mode value. Values must start from 0 and be contiguous.
     private static final int RINGER_MODE_MAX = RINGER_MODE_NORMAL;
 
     /**
-     * Vibrate type that corresponds to the ringer.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Vibrate type that corresponds to the ringer.
+*
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @see #shouldVibrate(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public static final int VIBRATE_TYPE_RINGER = 0;
 
     /**
-     * Vibrate type that corresponds to notifications.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Vibrate type that corresponds to notifications.
+*
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @see #shouldVibrate(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public static final int VIBRATE_TYPE_NOTIFICATION = 1;
 
     /**
-     * Vibrate setting that suggests to never vibrate.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Vibrate setting that suggests to never vibrate.
+*
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public static final int VIBRATE_SETTING_OFF = 0;
 
     /**
-     * Vibrate setting that suggests to vibrate when possible.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Vibrate setting that suggests to vibrate when possible.
+*
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public static final int VIBRATE_SETTING_ON = 1;
 
     /**
-     * Vibrate setting that suggests to only vibrate when in the vibrate ringer
-     * mode.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Vibrate setting that suggests to only vibrate when in the vibrate ringer
+* mode.
+*
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public static final int VIBRATE_SETTING_ONLY_SILENT = 2;
 
     /**
-     * Suggests using the default stream type. This may not be used in all
-     * places a stream type is needed.
-     */
+* Suggests using the default stream type. This may not be used in all
+* places a stream type is needed.
+*/
     public static final int USE_DEFAULT_STREAM_TYPE = Integer.MIN_VALUE;
 
     private static IAudioService sService;
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public AudioManager(Context context) {
         mContext = context;
         mUseMasterVolume = mContext.getResources().getBoolean(
@@ -445,28 +445,28 @@ public class AudioManager {
     }
 
     /**
-     * Sends a simulated key event for a media button.
-     * To simulate a key press, you must first send a KeyEvent built with a
-     * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
-     * action.
-     * <p>The key event will be sent to the current media key event consumer which registered with
-     * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
-     * @param keyEvent a {@link KeyEvent} instance whose key code is one of
-     *     {@link KeyEvent#KEYCODE_MUTE},
-     *     {@link KeyEvent#KEYCODE_HEADSETHOOK},
-     *     {@link KeyEvent#KEYCODE_MEDIA_PLAY},
-     *     {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
-     *     {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
-     *     {@link KeyEvent#KEYCODE_MEDIA_STOP},
-     *     {@link KeyEvent#KEYCODE_MEDIA_NEXT},
-     *     {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
-     *     {@link KeyEvent#KEYCODE_MEDIA_REWIND},
-     *     {@link KeyEvent#KEYCODE_MEDIA_RECORD},
-     *     {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
-     *     {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
-     *     {@link KeyEvent#KEYCODE_MEDIA_EJECT},
-     *     or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
-     */
+* Sends a simulated key event for a media button.
+* To simulate a key press, you must first send a KeyEvent built with a
+* {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
+* action.
+* <p>The key event will be sent to the current media key event consumer which registered with
+* {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
+* @param keyEvent a {@link KeyEvent} instance whose key code is one of
+* {@link KeyEvent#KEYCODE_MUTE},
+* {@link KeyEvent#KEYCODE_HEADSETHOOK},
+* {@link KeyEvent#KEYCODE_MEDIA_PLAY},
+* {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
+* {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
+* {@link KeyEvent#KEYCODE_MEDIA_STOP},
+* {@link KeyEvent#KEYCODE_MEDIA_NEXT},
+* {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
+* {@link KeyEvent#KEYCODE_MEDIA_REWIND},
+* {@link KeyEvent#KEYCODE_MEDIA_RECORD},
+* {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
+* {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
+* {@link KeyEvent#KEYCODE_MEDIA_EJECT},
+* or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
+*/
     public void dispatchMediaKeyEvent(KeyEvent keyEvent) {
         IAudioService service = getService();
         try {
@@ -477,22 +477,22 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public void preDispatchKeyEvent(KeyEvent event, int stream) {
         /*
-         * If the user hits another key within the play sound delay, then
-         * cancel the sound
-         */
+* If the user hits another key within the play sound delay, then
+* cancel the sound
+*/
         int keyCode = event.getKeyCode();
         if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP
                 && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE
                 && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY
                         > SystemClock.uptimeMillis()) {
             /*
-             * The user has hit another key during the delay (e.g., 300ms)
-             * since the last volume key up, so cancel any sounds.
-             */
+* The user has hit another key during the delay (e.g., 300ms)
+* since the last volume key up, so cancel any sounds.
+*/
             if (mUseMasterVolume) {
                 adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
             } else {
@@ -503,19 +503,22 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public void handleKeyDown(KeyEvent event, int stream) {
         int keyCode = event.getKeyCode();
         switch (keyCode) {
             case KeyEvent.KEYCODE_VOLUME_UP:
             case KeyEvent.KEYCODE_VOLUME_DOWN:
                 /*
-                 * Adjust the volume in on key down since it is more
-                 * responsive to the user.
-                 */
+* Adjust the volume in on key down since it is more
+* responsive to the user.
+*/
                 int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
 
+                if(isStreamMute(3))
+		    setStreamMute(3, !isStreamMute(3));
+
                 if (mUseMasterVolume) {
                     adjustMasterVolume(
                             keyCode == KeyEvent.KEYCODE_VOLUME_UP
@@ -533,10 +536,11 @@ public class AudioManager {
                 break;
             case KeyEvent.KEYCODE_VOLUME_MUTE:
                 if (event.getRepeatCount() == 0) {
+                    Log.i(TAG, "KEYCODE_VOLUME_MUTE stream="+stream+" mUseMasterVolume=%d"+mUseMasterVolume);
                     if (mUseMasterVolume) {
                         setMasterMute(!isMasterMute());
                     } else {
-                        // TODO: Actually handle MUTE.
+                       setStreamMute(3, !isStreamMute(3));
                     }
                 }
                 break;
@@ -544,17 +548,17 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public void handleKeyUp(KeyEvent event, int stream) {
         int keyCode = event.getKeyCode();
         switch (keyCode) {
             case KeyEvent.KEYCODE_VOLUME_UP:
             case KeyEvent.KEYCODE_VOLUME_DOWN:
                 /*
-                 * Play a sound. This is done on key up since we don't want the
-                 * sound to play when a user holds down volume down to mute.
-                 */
+* Play a sound. This is done on key up since we don't want the
+* sound to play when a user holds down volume down to mute.
+*/
                 if (mUseVolumeKeySounds) {
                     if (mUseMasterVolume) {
                         adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
@@ -572,21 +576,21 @@ public class AudioManager {
     }
 
     /**
-     * Adjusts the volume of a particular stream by one step in a direction.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
-     * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
-     * {@link #STREAM_ALARM}
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param flags One or more flags.
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
+* Adjusts the volume of a particular stream by one step in a direction.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
+* {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
+* {@link #STREAM_ALARM}
+* @param direction The direction to adjust the volume. One of
+* {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+* {@link #ADJUST_SAME}.
+* @param flags One or more flags.
+* @see #adjustVolume(int, int)
+* @see #setStreamVolume(int, int, int)
+*/
     public void adjustStreamVolume(int streamType, int direction, int flags) {
         IAudioService service = getService();
         try {
@@ -602,22 +606,22 @@ public class AudioManager {
     }
 
     /**
-     * Adjusts the volume of the most relevant stream. For example, if a call is
-     * active, it will have the highest priority regardless of if the in-call
-     * screen is showing. Another example, if music is playing in the background
-     * and a call is not active, the music stream will be adjusted.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param flags One or more flags.
-     * @see #adjustSuggestedStreamVolume(int, int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
+* Adjusts the volume of the most relevant stream. For example, if a call is
+* active, it will have the highest priority regardless of if the in-call
+* screen is showing. Another example, if music is playing in the background
+* and a call is not active, the music stream will be adjusted.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param direction The direction to adjust the volume. One of
+* {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+* {@link #ADJUST_SAME}.
+* @param flags One or more flags.
+* @see #adjustSuggestedStreamVolume(int, int, int)
+* @see #adjustStreamVolume(int, int, int)
+* @see #setStreamVolume(int, int, int)
+*/
     public void adjustVolume(int direction, int flags) {
         IAudioService service = getService();
         try {
@@ -632,22 +636,22 @@ public class AudioManager {
     }
 
     /**
-     * Adjusts the volume of the most relevant stream, or the given fallback
-     * stream.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param suggestedStreamType The stream type that will be used if there
-     *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
-     * @param flags One or more flags.
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
+* Adjusts the volume of the most relevant stream, or the given fallback
+* stream.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param direction The direction to adjust the volume. One of
+* {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+* {@link #ADJUST_SAME}.
+* @param suggestedStreamType The stream type that will be used if there
+* isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
+* @param flags One or more flags.
+* @see #adjustVolume(int, int)
+* @see #adjustStreamVolume(int, int, int)
+* @see #setStreamVolume(int, int, int)
+*/
     public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
         IAudioService service = getService();
         try {
@@ -663,14 +667,14 @@ public class AudioManager {
     }
 
     /**
-     * Adjusts the master volume for the device's audio amplifier.
-     * <p>
-     *
-     * @param steps The number of volume steps to adjust. A positive
-     *            value will raise the volume.
-     * @param flags One or more flags.
-     * @hide
-     */
+* Adjusts the master volume for the device's audio amplifier.
+* <p>
+*
+* @param steps The number of volume steps to adjust. A positive
+* value will raise the volume.
+* @param flags One or more flags.
+* @hide
+*/
     public void adjustMasterVolume(int steps, int flags) {
         IAudioService service = getService();
         try {
@@ -681,12 +685,12 @@ public class AudioManager {
     }
 
     /**
-     * Returns the current ringtone mode.
-     *
-     * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
-     *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
-     * @see #setRingerMode(int)
-     */
+* Returns the current ringtone mode.
+*
+* @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
+* {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
+* @see #setRingerMode(int)
+*/
     public int getRingerMode() {
         IAudioService service = getService();
         try {
@@ -698,13 +702,13 @@ public class AudioManager {
     }
 
     /**
-     * Checks valid ringer mode values.
-     *
-     * @return true if the ringer mode indicated is valid, false otherwise.
-     *
-     * @see #setRingerMode(int)
-     * @hide
-     */
+* Checks valid ringer mode values.
+*
+* @return true if the ringer mode indicated is valid, false otherwise.
+*
+* @see #setRingerMode(int)
+* @hide
+*/
     public static boolean isValidRingerMode(int ringerMode) {
         if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
             return false;
@@ -713,12 +717,12 @@ public class AudioManager {
     }
 
     /**
-     * Returns the maximum volume index for a particular stream.
-     *
-     * @param streamType The stream type whose maximum volume index is returned.
-     * @return The maximum valid volume index for the stream.
-     * @see #getStreamVolume(int)
-     */
+* Returns the maximum volume index for a particular stream.
+*
+* @param streamType The stream type whose maximum volume index is returned.
+* @return The maximum valid volume index for the stream.
+* @see #getStreamVolume(int)
+*/
     public int getStreamMaxVolume(int streamType) {
         IAudioService service = getService();
         try {
@@ -734,13 +738,13 @@ public class AudioManager {
     }
 
     /**
-     * Returns the current volume index for a particular stream.
-     *
-     * @param streamType The stream type whose volume index is returned.
-     * @return The current volume index for the stream.
-     * @see #getStreamMaxVolume(int)
-     * @see #setStreamVolume(int, int, int)
-     */
+* Returns the current volume index for a particular stream.
+*
+* @param streamType The stream type whose volume index is returned.
+* @return The current volume index for the stream.
+* @see #getStreamMaxVolume(int)
+* @see #setStreamVolume(int, int, int)
+*/
     public int getStreamVolume(int streamType) {
         IAudioService service = getService();
         try {
@@ -756,10 +760,10 @@ public class AudioManager {
     }
 
     /**
-     * Get last audible volume before stream was muted.
-     *
-     * @hide
-     */
+* Get last audible volume before stream was muted.
+*
+* @hide
+*/
     public int getLastAudibleStreamVolume(int streamType) {
         IAudioService service = getService();
         try {
@@ -775,10 +779,10 @@ public class AudioManager {
     }
 
     /**
-     * Get the stream type whose volume is driving the UI sounds volume.
-     * UI sounds are screen lock/unlock, camera shutter, key clicks...
-     * @hide
-     */
+* Get the stream type whose volume is driving the UI sounds volume.
+* UI sounds are screen lock/unlock, camera shutter, key clicks...
+* @hide
+*/
     public int getMasterStreamType() {
         IAudioService service = getService();
         try {
@@ -790,16 +794,16 @@ public class AudioManager {
     }
 
     /**
-     * Sets the ringer mode.
-     * <p>
-     * Silent mode will mute the volume and will not vibrate. Vibrate mode will
-     * mute the volume and vibrate. Normal mode will be audible and may vibrate
-     * according to user settings.
-     *
-     * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
-     *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
-     * @see #getRingerMode()
-     */
+* Sets the ringer mode.
+* <p>
+* Silent mode will mute the volume and will not vibrate. Vibrate mode will
+* mute the volume and vibrate. Normal mode will be audible and may vibrate
+* according to user settings.
+*
+* @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
+* {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
+* @see #getRingerMode()
+*/
     public void setRingerMode(int ringerMode) {
         if (!isValidRingerMode(ringerMode)) {
             return;
@@ -813,15 +817,15 @@ public class AudioManager {
     }
 
     /**
-     * Sets the volume index for a particular stream.
-     *
-     * @param streamType The stream whose volume index should be set.
-     * @param index The volume index to set. See
-     *            {@link #getStreamMaxVolume(int)} for the largest valid value.
-     * @param flags One or more flags.
-     * @see #getStreamMaxVolume(int)
-     * @see #getStreamVolume(int)
-     */
+* Sets the volume index for a particular stream.
+*
+* @param streamType The stream whose volume index should be set.
+* @param index The volume index to set. See
+* {@link #getStreamMaxVolume(int)} for the largest valid value.
+* @param flags One or more flags.
+* @see #getStreamMaxVolume(int)
+* @see #getStreamVolume(int)
+*/
     public void setStreamVolume(int streamType, int index, int flags) {
         IAudioService service = getService();
         try {
@@ -836,10 +840,10 @@ public class AudioManager {
     }
 
     /**
-     * Returns the maximum volume index for master volume.
-     *
-     * @hide
-     */
+* Returns the maximum volume index for master volume.
+*
+* @hide
+*/
     public int getMasterMaxVolume() {
         IAudioService service = getService();
         try {
@@ -851,11 +855,11 @@ public class AudioManager {
     }
 
     /**
-     * Returns the current volume index for master volume.
-     *
-     * @return The current volume index for master volume.
-     * @hide
-     */
+* Returns the current volume index for master volume.
+*
+* @return The current volume index for master volume.
+* @hide
+*/
     public int getMasterVolume() {
         IAudioService service = getService();
         try {
@@ -867,10 +871,10 @@ public class AudioManager {
     }
 
     /**
-     * Get last audible volume before master volume was muted.
-     *
-     * @hide
-     */
+* Get last audible volume before master volume was muted.
+*
+* @hide
+*/
     public int getLastAudibleMasterVolume() {
         IAudioService service = getService();
         try {
@@ -882,15 +886,15 @@ public class AudioManager {
     }
 
     /**
-     * Sets the volume index for master volume.
-     *
-     * @param index The volume index to set. See
-     *            {@link #getMasterMaxVolume()} for the largest valid value.
-     * @param flags One or more flags.
-     * @see #getMasterMaxVolume()
-     * @see #getMasterVolume()
-     * @hide
-     */
+* Sets the volume index for master volume.
+*
+* @param index The volume index to set. See
+* {@link #getMasterMaxVolume()} for the largest valid value.
+* @param flags One or more flags.
+* @see #getMasterMaxVolume()
+* @see #getMasterVolume()
+* @hide
+*/
     public void setMasterVolume(int index, int flags) {
         IAudioService service = getService();
         try {
@@ -901,22 +905,22 @@ public class AudioManager {
     }
 
     /**
-     * Solo or unsolo a particular stream. All other streams are muted.
-     * <p>
-     * The solo command is protected against client process death: if a process
-     * with an active solo request on a stream dies, all streams that were muted
-     * because of this request will be unmuted automatically.
-     * <p>
-     * The solo requests for a given stream are cumulative: the AudioManager
-     * can receive several solo requests from one or more clients and the stream
-     * will be unsoloed only when the same number of unsolo requests are received.
-     * <p>
-     * For a better user experience, applications MUST unsolo a soloed stream
-     * in onPause() and solo is again in onResume() if appropriate.
-     *
-     * @param streamType The stream to be soloed/unsoloed.
-     * @param state The required solo state: true for solo ON, false for solo OFF
-     */
+* Solo or unsolo a particular stream. All other streams are muted.
+* <p>
+* The solo command is protected against client process death: if a process
+* with an active solo request on a stream dies, all streams that were muted
+* because of this request will be unmuted automatically.
+* <p>
+* The solo requests for a given stream are cumulative: the AudioManager
+* can receive several solo requests from one or more clients and the stream
+* will be unsoloed only when the same number of unsolo requests are received.
+* <p>
+* For a better user experience, applications MUST unsolo a soloed stream
+* in onPause() and solo is again in onResume() if appropriate.
+*
+* @param streamType The stream to be soloed/unsoloed.
+* @param state The required solo state: true for solo ON, false for solo OFF
+*/
     public void setStreamSolo(int streamType, boolean state) {
         IAudioService service = getService();
         try {
@@ -927,25 +931,25 @@ public class AudioManager {
     }
 
     /**
-     * Mute or unmute an audio stream.
-     * <p>
-     * The mute command is protected against client process death: if a process
-     * with an active mute request on a stream dies, this stream will be unmuted
-     * automatically.
-     * <p>
-     * The mute requests for a given stream are cumulative: the AudioManager
-     * can receive several mute requests from one or more clients and the stream
-     * will be unmuted only when the same number of unmute requests are received.
-     * <p>
-     * For a better user experience, applications MUST unmute a muted stream
-     * in onPause() and mute is again in onResume() if appropriate.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param streamType The stream to be muted/unmuted.
-     * @param state The required mute state: true for mute ON, false for mute OFF
-     */
+* Mute or unmute an audio stream.
+* <p>
+* The mute command is protected against client process death: if a process
+* with an active mute request on a stream dies, this stream will be unmuted
+* automatically.
+* <p>
+* The mute requests for a given stream are cumulative: the AudioManager
+* can receive several mute requests from one or more clients and the stream
+* will be unmuted only when the same number of unmute requests are received.
+* <p>
+* For a better user experience, applications MUST unmute a muted stream
+* in onPause() and mute is again in onResume() if appropriate.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param streamType The stream to be muted/unmuted.
+* @param state The required mute state: true for mute ON, false for mute OFF
+*/
     public void setStreamMute(int streamType, boolean state) {
         IAudioService service = getService();
         try {
@@ -956,10 +960,10 @@ public class AudioManager {
     }
 
     /**
-     * get stream mute state.
-     *
-     * @hide
-     */
+* get stream mute state.
+*
+* @hide
+*/
     public boolean isStreamMute(int streamType) {
         IAudioService service = getService();
         try {
@@ -971,19 +975,19 @@ public class AudioManager {
     }
 
     /**
-     * set master mute state.
-     *
-     * @hide
-     */
+* set master mute state.
+*
+* @hide
+*/
     public void setMasterMute(boolean state) {
         setMasterMute(state, FLAG_SHOW_UI);
     }
 
     /**
-     * set master mute state with optional flags.
-     *
-     * @hide
-     */
+* set master mute state with optional flags.
+*
+* @hide
+*/
     public void setMasterMute(boolean state, int flags) {
         IAudioService service = getService();
         try {
@@ -994,10 +998,10 @@ public class AudioManager {
     }
 
     /**
-     * get master mute state.
-     *
-     * @hide
-     */
+* get master mute state.
+*
+* @hide
+*/
     public boolean isMasterMute() {
         IAudioService service = getService();
         try {
@@ -1009,12 +1013,12 @@ public class AudioManager {
     }
 
     /**
-     * forces the stream controlled by hard volume keys
-     * specifying streamType == -1 releases control to the
-     * logic.
-     *
-     * @hide
-     */
+* forces the stream controlled by hard volume keys
+* specifying streamType == -1 releases control to the
+* logic.
+*
+* @hide
+*/
     public void forceVolumeControlStream(int streamType) {
         IAudioService service = getService();
         try {
@@ -1025,24 +1029,24 @@ public class AudioManager {
     }
 
     /**
-     * Returns whether a particular type should vibrate according to user
-     * settings and the current ringer mode.
-     * <p>
-     * This shouldn't be needed by most clients that use notifications to
-     * vibrate. The notification manager will not vibrate if the policy doesn't
-     * allow it, so the client should always set a vibrate pattern and let the
-     * notification manager control whether or not to actually vibrate.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @return Whether the type should vibrate at the instant this method is
-     *         called.
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Returns whether a particular type should vibrate according to user
+* settings and the current ringer mode.
+* <p>
+* This shouldn't be needed by most clients that use notifications to
+* vibrate. The notification manager will not vibrate if the policy doesn't
+* allow it, so the client should always set a vibrate pattern and let the
+* notification manager control whether or not to actually vibrate.
+*
+* @param vibrateType The type of vibrate. One of
+* {@link #VIBRATE_TYPE_NOTIFICATION} or
+* {@link #VIBRATE_TYPE_RINGER}.
+* @return Whether the type should vibrate at the instant this method is
+* called.
+* @see #setVibrateSetting(int, int)
+* @see #getVibrateSetting(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public boolean shouldVibrate(int vibrateType) {
         IAudioService service = getService();
         try {
@@ -1054,22 +1058,22 @@ public class AudioManager {
     }
 
     /**
-     * Returns whether the user's vibrate setting for a vibrate type.
-     * <p>
-     * This shouldn't be needed by most clients that want to vibrate, instead
-     * see {@link #shouldVibrate(int)}.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
-     *         {@link #VIBRATE_SETTING_OFF}, or
-     *         {@link #VIBRATE_SETTING_ONLY_SILENT}.
-     * @see #setVibrateSetting(int, int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Returns whether the user's vibrate setting for a vibrate type.
+* <p>
+* This shouldn't be needed by most clients that want to vibrate, instead
+* see {@link #shouldVibrate(int)}.
+*
+* @param vibrateType The type of vibrate. One of
+* {@link #VIBRATE_TYPE_NOTIFICATION} or
+* {@link #VIBRATE_TYPE_RINGER}.
+* @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
+* {@link #VIBRATE_SETTING_OFF}, or
+* {@link #VIBRATE_SETTING_ONLY_SILENT}.
+* @see #setVibrateSetting(int, int)
+* @see #shouldVibrate(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public int getVibrateSetting(int vibrateType) {
         IAudioService service = getService();
         try {
@@ -1081,23 +1085,23 @@ public class AudioManager {
     }
 
     /**
-     * Sets the setting for when the vibrate type should vibrate.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @param vibrateSetting The vibrate setting, one of
-     *            {@link #VIBRATE_SETTING_ON},
-     *            {@link #VIBRATE_SETTING_OFF}, or
-     *            {@link #VIBRATE_SETTING_ONLY_SILENT}.
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
+* Sets the setting for when the vibrate type should vibrate.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param vibrateType The type of vibrate. One of
+* {@link #VIBRATE_TYPE_NOTIFICATION} or
+* {@link #VIBRATE_TYPE_RINGER}.
+* @param vibrateSetting The vibrate setting, one of
+* {@link #VIBRATE_SETTING_ON},
+* {@link #VIBRATE_SETTING_OFF}, or
+* {@link #VIBRATE_SETTING_ONLY_SILENT}.
+* @see #getVibrateSetting(int)
+* @see #shouldVibrate(int)
+* @deprecated Applications should maintain their own vibrate policy based on
+* current ringer mode that can be queried via {@link #getRingerMode()}.
+*/
     public void setVibrateSetting(int vibrateType, int vibrateSetting) {
         IAudioService service = getService();
         try {
@@ -1108,14 +1112,14 @@ public class AudioManager {
     }
 
     /**
-     * Sets the speakerphone on or off.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to turn on speakerphone;
-     *           <var>false</var> to turn it off
-     */
+* Sets the speakerphone on or off.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param on set <var>true</var> to turn on speakerphone;
+* <var>false</var> to turn it off
+*/
     public void setSpeakerphoneOn(boolean on){
         IAudioService service = getService();
         try {
@@ -1126,10 +1130,10 @@ public class AudioManager {
     }
 
     /**
-     * Checks whether the speakerphone is on or off.
-     *
-     * @return true if speakerphone is on, false if it's off
-     */
+* Checks whether the speakerphone is on or off.
+*
+* @return true if speakerphone is on, false if it's off
+*/
     public boolean isSpeakerphoneOn() {
         IAudioService service = getService();
         try {
@@ -1143,134 +1147,134 @@ public class AudioManager {
     //====================================================================
     // Bluetooth SCO control
     /**
-     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
-     * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}
-     * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}
-     * or {@link #SCO_AUDIO_STATE_CONNECTED}
-     *
-     * @see #startBluetoothSco()
-     * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead
-     */
+* Sticky broadcast intent action indicating that the bluetoooth SCO audio
+* connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}
+* indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}
+* or {@link #SCO_AUDIO_STATE_CONNECTED}
+*
+* @see #startBluetoothSco()
+* @deprecated Use {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead
+*/
     @Deprecated
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String ACTION_SCO_AUDIO_STATE_CHANGED =
             "android.media.SCO_AUDIO_STATE_CHANGED";
 
      /**
-     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
-     * connection state has been updated.
-     * <p>This intent has two extras:
-     * <ul>
-     *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>
-     *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>
-     * </ul>
-     * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
-     * <ul>
-     *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>
-     *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>
-     *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>
-     * </ul>
-     * @see #startBluetoothSco()
-     */
+* Sticky broadcast intent action indicating that the bluetoooth SCO audio
+* connection state has been updated.
+* <p>This intent has two extras:
+* <ul>
+* <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>
+* <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>
+* </ul>
+* <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
+* <ul>
+* <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>
+* <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>
+* <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>
+* </ul>
+* @see #startBluetoothSco()
+*/
     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
     public static final String ACTION_SCO_AUDIO_STATE_UPDATED =
             "android.media.ACTION_SCO_AUDIO_STATE_UPDATED";
 
     /**
-     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or
-     * {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.
-     */
+* Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or
+* {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.
+*/
     public static final String EXTRA_SCO_AUDIO_STATE =
             "android.media.extra.SCO_AUDIO_STATE";
 
     /**
-     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous
-     * bluetooth SCO connection state.
-     */
+* Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous
+* bluetooth SCO connection state.
+*/
     public static final String EXTRA_SCO_AUDIO_PREVIOUS_STATE =
             "android.media.extra.SCO_AUDIO_PREVIOUS_STATE";
 
     /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
-     * indicating that the SCO audio channel is not established
-     */
+* Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
+* indicating that the SCO audio channel is not established
+*/
     public static final int SCO_AUDIO_STATE_DISCONNECTED = 0;
     /**
-     * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}
-     * indicating that the SCO audio channel is established
-     */
+* Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}
+* indicating that the SCO audio channel is established
+*/
     public static final int SCO_AUDIO_STATE_CONNECTED = 1;
     /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
-     * indicating that the SCO audio channel is being established
-     */
+* Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
+* indicating that the SCO audio channel is being established
+*/
     public static final int SCO_AUDIO_STATE_CONNECTING = 2;
     /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE indicating that
-     * there was an error trying to obtain the state
-     */
+* Value for extra EXTRA_SCO_AUDIO_STATE indicating that
+* there was an error trying to obtain the state
+*/
     public static final int SCO_AUDIO_STATE_ERROR = -1;
 
 
     /**
-     * Indicates if current platform supports use of SCO for off call use cases.
-     * Application wanted to use bluetooth SCO audio when the phone is not in call
-     * must first call this method to make sure that the platform supports this
-     * feature.
-     * @return true if bluetooth SCO can be used for audio when not in call
-     *         false otherwise
-     * @see #startBluetoothSco()
-    */
+* Indicates if current platform supports use of SCO for off call use cases.
+* Application wanted to use bluetooth SCO audio when the phone is not in call
+* must first call this method to make sure that the platform supports this
+* feature.
+* @return true if bluetooth SCO can be used for audio when not in call
+* false otherwise
+* @see #startBluetoothSco()
+*/
     public boolean isBluetoothScoAvailableOffCall() {
         return mContext.getResources().getBoolean(
                com.android.internal.R.bool.config_bluetooth_sco_off_call);
     }
 
     /**
-     * Start bluetooth SCO audio connection.
-     * <p>Requires Permission:
-     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
-     * <p>This method can be used by applications wanting to send and received audio
-     * to/from a bluetooth SCO headset while the phone is not in call.
-     * <p>As the SCO connection establishment can take several seconds,
-     * applications should not rely on the connection to be available when the method
-     * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
-     * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
-     * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
-     * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
-     * registration. If the state is already CONNECTED, no state change will be received via the
-     * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
-     * so that the connection stays active in case the current initiator stops the connection.
-     * <p>Unless the connection is already active as described above, the state will always
-     * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
-     * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
-     * <p>When finished with the SCO connection or if the establishment fails, the application must
-     * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
-     * <p>Even if a SCO connection is established, the following restrictions apply on audio
-     * output streams so that they can be routed to SCO headset:
-     * <p>NOTE: up to and including API version
-     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual
-     * voice call to the bluetooth headset.
-     * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio
-     * connection is established.
-     * <ul>
-     *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
-     *   <li> the format must be mono </li>
-     *   <li> the sampling must be 16kHz or 8kHz </li>
-     * </ul>
-     * <p>The following restrictions apply on input streams:
-     * <ul>
-     *   <li> the format must be mono </li>
-     *   <li> the sampling must be 8kHz </li>
-     * </ul>
-     * <p>Note that the phone application always has the priority on the usage of the SCO
-     * connection for telephony. If this method is called while the phone is in call
-     * it will be ignored. Similarly, if a call is received or sent while an application
-     * is using the SCO connection, the connection will be lost for the application and NOT
-     * returned automatically when the call ends.
-     * @see #stopBluetoothSco()
-     * @see #ACTION_SCO_AUDIO_STATE_UPDATED
-     */
+* Start bluetooth SCO audio connection.
+* <p>Requires Permission:
+* {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
+* <p>This method can be used by applications wanting to send and received audio
+* to/from a bluetooth SCO headset while the phone is not in call.
+* <p>As the SCO connection establishment can take several seconds,
+* applications should not rely on the connection to be available when the method
+* returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
+* and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
+* <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
+* audio state before calling startBluetoothSco() by reading the intent returned by the receiver
+* registration. If the state is already CONNECTED, no state change will be received via the
+* intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
+* so that the connection stays active in case the current initiator stops the connection.
+* <p>Unless the connection is already active as described above, the state will always
+* transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
+* succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
+* <p>When finished with the SCO connection or if the establishment fails, the application must
+* call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
+* <p>Even if a SCO connection is established, the following restrictions apply on audio
+* output streams so that they can be routed to SCO headset:
+* <p>NOTE: up to and including API version
+* {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual
+* voice call to the bluetooth headset.
+* After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio
+* connection is established.
+* <ul>
+* <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
+* <li> the format must be mono </li>
+* <li> the sampling must be 16kHz or 8kHz </li>
+* </ul>
+* <p>The following restrictions apply on input streams:
+* <ul>
+* <li> the format must be mono </li>
+* <li> the sampling must be 8kHz </li>
+* </ul>
+* <p>Note that the phone application always has the priority on the usage of the SCO
+* connection for telephony. If this method is called while the phone is in call
+* it will be ignored. Similarly, if a call is received or sent while an application
+* is using the SCO connection, the connection will be lost for the application and NOT
+* returned automatically when the call ends.
+* @see #stopBluetoothSco()
+* @see #ACTION_SCO_AUDIO_STATE_UPDATED
+*/
     public void startBluetoothSco(){
         IAudioService service = getService();
         try {
@@ -1281,14 +1285,14 @@ public class AudioManager {
     }
 
     /**
-     * Stop bluetooth SCO audio connection.
-     * <p>Requires Permission:
-     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
-     * <p>This method must be called by applications having requested the use of
-     * bluetooth SCO audio with {@link #startBluetoothSco()}
-     * when finished with the SCO connection or if connection fails.
-     * @see #startBluetoothSco()
-     */
+* Stop bluetooth SCO audio connection.
+* <p>Requires Permission:
+* {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
+* <p>This method must be called by applications having requested the use of
+* bluetooth SCO audio with {@link #startBluetoothSco()}
+* when finished with the SCO connection or if connection fails.
+* @see #startBluetoothSco()
+*/
     public void stopBluetoothSco(){
         IAudioService service = getService();
         try {
@@ -1299,14 +1303,14 @@ public class AudioManager {
     }
 
     /**
-     * Request use of Bluetooth SCO headset for communications.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to use bluetooth SCO for communications;
-     *               <var>false</var> to not use bluetooth SCO for communications
-     */
+* Request use of Bluetooth SCO headset for communications.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param on set <var>true</var> to use bluetooth SCO for communications;
+* <var>false</var> to not use bluetooth SCO for communications
+*/
     public void setBluetoothScoOn(boolean on){
         IAudioService service = getService();
         try {
@@ -1317,11 +1321,11 @@ public class AudioManager {
     }
 
     /**
-     * Checks whether communications use Bluetooth SCO.
-     *
-     * @return true if SCO is used for communications;
-     *         false if otherwise
-     */
+* Checks whether communications use Bluetooth SCO.
+*
+* @return true if SCO is used for communications;
+* false if otherwise
+*/
     public boolean isBluetoothScoOn() {
         IAudioService service = getService();
         try {
@@ -1333,19 +1337,19 @@ public class AudioManager {
     }
 
     /**
-     * @param on set <var>true</var> to route A2DP audio to/from Bluetooth
-     *           headset; <var>false</var> disable A2DP audio
-     * @deprecated Do not use.
-     */
+* @param on set <var>true</var> to route A2DP audio to/from Bluetooth
+* headset; <var>false</var> disable A2DP audio
+* @deprecated Do not use.
+*/
     @Deprecated public void setBluetoothA2dpOn(boolean on){
     }
 
     /**
-     * Checks whether A2DP audio routing to the Bluetooth headset is on or off.
-     *
-     * @return true if A2DP audio is being routed to/from Bluetooth headset;
-     *         false if otherwise
-     */
+* Checks whether A2DP audio routing to the Bluetooth headset is on or off.
+*
+* @return true if A2DP audio is being routed to/from Bluetooth headset;
+* false if otherwise
+*/
     public boolean isBluetoothA2dpOn() {
         if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP,"")
             == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
@@ -1356,24 +1360,24 @@ public class AudioManager {
     }
 
     /**
-     * Sets audio routing to the wired headset on or off.
-     *
-     * @param on set <var>true</var> to route audio to/from wired
-     *           headset; <var>false</var> disable wired headset audio
-     * @deprecated Do not use.
-     */
+* Sets audio routing to the wired headset on or off.
+*
+* @param on set <var>true</var> to route audio to/from wired
+* headset; <var>false</var> disable wired headset audio
+* @deprecated Do not use.
+*/
     @Deprecated public void setWiredHeadsetOn(boolean on){
     }
 
     /**
-     * Checks whether a wired headset is connected or not.
-     * <p>This is not a valid indication that audio playback is
-     * actually over the wired headset as audio routing depends on other conditions.
-     *
-     * @return true if a wired headset is connected.
-     *         false if otherwise
-     * @deprecated Use only to check is a headset is connected or not.
-     */
+* Checks whether a wired headset is connected or not.
+* <p>This is not a valid indication that audio playback is
+* actually over the wired headset as audio routing depends on other conditions.
+*
+* @return true if a wired headset is connected.
+* false if otherwise
+* @deprecated Use only to check is a headset is connected or not.
+*/
     public boolean isWiredHeadsetOn() {
         if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADSET,"")
                 == AudioSystem.DEVICE_STATE_UNAVAILABLE &&
@@ -1386,42 +1390,42 @@ public class AudioManager {
     }
 
     /**
-     * Sets the microphone mute on or off.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to mute the microphone;
-     *           <var>false</var> to turn mute off
-     */
+* Sets the microphone mute on or off.
+* <p>
+* This method should only be used by applications that replace the platform-wide
+* management of audio settings or the main telephony application.
+*
+* @param on set <var>true</var> to mute the microphone;
+* <var>false</var> to turn mute off
+*/
     public void setMicrophoneMute(boolean on){
         AudioSystem.muteMicrophone(on);
     }
 
     /**
-     * Checks whether the microphone mute is on or off.
-     *
-     * @return true if microphone is muted, false if it's not
-     */
+* Checks whether the microphone mute is on or off.
+*
+* @return true if microphone is muted, false if it's not
+*/
     public boolean isMicrophoneMute() {
         return AudioSystem.isMicrophoneMuted();
     }
 
     /**
-     * Sets the audio mode.
-     * <p>
-     * The audio mode encompasses audio routing AND the behavior of
-     * the telephony layer. Therefore this method should only be used by applications that
-     * replace the platform-wide management of audio settings or the main telephony application.
-     * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
-     * application when it places a phone call, as it will cause signals from the radio layer
-     * to feed the platform mixer.
-     *
-     * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
-     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
-     *              Informs the HAL about the current audio state so that
-     *              it can route the audio appropriately.
-     */
+* Sets the audio mode.
+* <p>
+* The audio mode encompasses audio routing AND the behavior of
+* the telephony layer. Therefore this method should only be used by applications that
+* replace the platform-wide management of audio settings or the main telephony application.
+* In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
+* application when it places a phone call, as it will cause signals from the radio layer
+* to feed the platform mixer.
+*
+* @param mode the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
+* {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
+* Informs the HAL about the current audio state so that
+* it can route the audio appropriately.
+*/
     public void setMode(int mode) {
         IAudioService service = getService();
         try {
@@ -1432,12 +1436,12 @@ public class AudioManager {
     }
 
     /**
-     * Returns the current audio mode.
-     *
-     * @return      the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
-     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
-     *              Returns the current current audio state from the HAL.
-     */
+* Returns the current audio mode.
+*
+* @return the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
+* {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
+* Returns the current current audio state from the HAL.
+*/
     public int getMode() {
         IAudioService service = getService();
         try {
@@ -1450,134 +1454,134 @@ public class AudioManager {
 
     /* modes for setMode/getMode/setRoute/getRoute */
     /**
-     * Audio harware modes.
-     */
+* Audio harware modes.
+*/
     /**
-     * Invalid audio mode.
-     */
-    public static final int MODE_INVALID            = AudioSystem.MODE_INVALID;
+* Invalid audio mode.
+*/
+    public static final int MODE_INVALID = AudioSystem.MODE_INVALID;
     /**
-     * Current audio mode. Used to apply audio routing to current mode.
-     */
-    public static final int MODE_CURRENT            = AudioSystem.MODE_CURRENT;
+* Current audio mode. Used to apply audio routing to current mode.
+*/
+    public static final int MODE_CURRENT = AudioSystem.MODE_CURRENT;
     /**
-     * Normal audio mode: not ringing and no call established.
-     */
-    public static final int MODE_NORMAL             = AudioSystem.MODE_NORMAL;
+* Normal audio mode: not ringing and no call established.
+*/
+    public static final int MODE_NORMAL = AudioSystem.MODE_NORMAL;
     /**
-     * Ringing audio mode. An incoming is being signaled.
-     */
-    public static final int MODE_RINGTONE           = AudioSystem.MODE_RINGTONE;
+* Ringing audio mode. An incoming is being signaled.
+*/
+    public static final int MODE_RINGTONE = AudioSystem.MODE_RINGTONE;
     /**
-     * In call audio mode. A telephony call is established.
-     */
-    public static final int MODE_IN_CALL            = AudioSystem.MODE_IN_CALL;
+* In call audio mode. A telephony call is established.
+*/
+    public static final int MODE_IN_CALL = AudioSystem.MODE_IN_CALL;
     /**
-     * In communication audio mode. An audio/video chat or VoIP call is established.
-     */
-    public static final int MODE_IN_COMMUNICATION   = AudioSystem.MODE_IN_COMMUNICATION;
+* In communication audio mode. An audio/video chat or VoIP call is established.
+*/
+    public static final int MODE_IN_COMMUNICATION = AudioSystem.MODE_IN_COMMUNICATION;
 
     /* Routing bits for setRouting/getRouting API */
     /**
-     * Routing audio output to earpiece
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_EARPIECE          = AudioSystem.ROUTE_EARPIECE;
-    /**
-     * Routing audio output to speaker
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_SPEAKER           = AudioSystem.ROUTE_SPEAKER;
-    /**
-     * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
+* Routing audio output to earpiece
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_EARPIECE = AudioSystem.ROUTE_EARPIECE;
+    /**
+* Routing audio output to speaker
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_SPEAKER = AudioSystem.ROUTE_SPEAKER;
+    /**
+* @deprecated use {@link #ROUTE_BLUETOOTH_SCO}
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
     @Deprecated public static final int ROUTE_BLUETOOTH = AudioSystem.ROUTE_BLUETOOTH_SCO;
     /**
-     * Routing audio output to bluetooth SCO
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_BLUETOOTH_SCO     = AudioSystem.ROUTE_BLUETOOTH_SCO;
-    /**
-     * Routing audio output to headset
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_HEADSET           = AudioSystem.ROUTE_HEADSET;
-    /**
-     * Routing audio output to bluetooth A2DP
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP    = AudioSystem.ROUTE_BLUETOOTH_A2DP;
-    /**
-     * Used for mask parameter of {@link #setRouting(int,int,int)}.
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_ALL               = AudioSystem.ROUTE_ALL;
-
-    /**
-     * Sets the audio routing for a specified mode
-     *
-     * @param mode   audio mode to change route. E.g., MODE_RINGTONE.
-     * @param routes bit vector of routes requested, created from one or
-     *               more of ROUTE_xxx types. Set bits indicate that route should be on
-     * @param mask   bit vector of routes to change, created from one or more of
-     * ROUTE_xxx types. Unset bits indicate the route should be left unchanged
-     *
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
+* Routing audio output to bluetooth SCO
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_BLUETOOTH_SCO = AudioSystem.ROUTE_BLUETOOTH_SCO;
+    /**
+* Routing audio output to headset
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_HEADSET = AudioSystem.ROUTE_HEADSET;
+    /**
+* Routing audio output to bluetooth A2DP
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP = AudioSystem.ROUTE_BLUETOOTH_A2DP;
+    /**
+* Used for mask parameter of {@link #setRouting(int,int,int)}.
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
+    @Deprecated public static final int ROUTE_ALL = AudioSystem.ROUTE_ALL;
+
+    /**
+* Sets the audio routing for a specified mode
+*
+* @param mode audio mode to change route. E.g., MODE_RINGTONE.
+* @param routes bit vector of routes requested, created from one or
+* more of ROUTE_xxx types. Set bits indicate that route should be on
+* @param mask bit vector of routes to change, created from one or more of
+* ROUTE_xxx types. Unset bits indicate the route should be left unchanged
+*
+* @deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
+* setBluetoothScoOn() methods instead.
+*/
     @Deprecated
     public void setRouting(int mode, int routes, int mask) {
     }
 
     /**
-     * Returns the current audio routing bit vector for a specified mode.
-     *
-     * @param mode audio mode to get route (e.g., MODE_RINGTONE)
-     * @return an audio route bit vector that can be compared with ROUTE_xxx
-     * bits
-     * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),
-     * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
-     */
+* Returns the current audio routing bit vector for a specified mode.
+*
+* @param mode audio mode to get route (e.g., MODE_RINGTONE)
+* @return an audio route bit vector that can be compared with ROUTE_xxx
+* bits
+* @deprecated Do not query audio routing directly, use isSpeakerphoneOn(),
+* isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
+*/
     @Deprecated
     public int getRouting(int mode) {
         return -1;
     }
 
     /**
-     * Checks whether any music is active.
-     *
-     * @return true if any music tracks are active.
-     */
+* Checks whether any music is active.
+*
+* @return true if any music tracks are active.
+*/
     public boolean isMusicActive() {
         return AudioSystem.isStreamActive(STREAM_MUSIC, 0);
     }
 
     /**
-     * @hide
-     * Checks whether any music or media is actively playing on a remote device (e.g. wireless
-     *   display). Note that BT audio sinks are not considered remote devices.
-     * @return true if {@link AudioManager#STREAM_MUSIC} is active on a remote device
-     */
+* @hide
+* Checks whether any music or media is actively playing on a remote device (e.g. wireless
+* display). Note that BT audio sinks are not considered remote devices.
+* @return true if {@link AudioManager#STREAM_MUSIC} is active on a remote device
+*/
     public boolean isMusicActiveRemotely() {
         return AudioSystem.isStreamActiveRemotely(STREAM_MUSIC, 0);
     }
 
     /**
-     * @hide
-     * Checks whether any local or remote media playback is active.
-     * Local playback refers to playback for instance on the device's speakers or wired headphones.
-     * Remote playback refers to playback for instance on a wireless display mirroring the
-     *    devices's, or on a device using a Cast-like protocol.
-     * @return true if media playback, from which the device is aware, is active.
-     */
+* @hide
+* Checks whether any local or remote media playback is active.
+* Local playback refers to playback for instance on the device's speakers or wired headphones.
+* Remote playback refers to playback for instance on a wireless display mirroring the
+* devices's, or on a device using a Cast-like protocol.
+* @return true if media playback, from which the device is aware, is active.
+*/
     public boolean isLocalOrRemoteMusicActive() {
         IAudioService service = getService();
         try {
@@ -1589,11 +1593,11 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Checks whether the current audio focus is exclusive.
-     * @return true if the top of the audio focus stack requested focus
-     *     with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}
-     */
+* @hide
+* Checks whether the current audio focus is exclusive.
+* @return true if the top of the audio focus stack requested focus
+* with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}
+*/
     public boolean isAudioFocusExclusive() {
         IAudioService service = getService();
         try {
@@ -1605,11 +1609,11 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * If the stream is active locally or remotely, adjust its volume according to the enforced
-     * priority rules.
-     * Note: only AudioManager.STREAM_MUSIC is supported at the moment
-     */
+* @hide
+* If the stream is active locally or remotely, adjust its volume according to the enforced
+* priority rules.
+* Note: only AudioManager.STREAM_MUSIC is supported at the moment
+*/
     public void adjustLocalOrRemoteStreamVolume(int streamType, int direction) {
         if (streamType != STREAM_MUSIC) {
             Log.w(TAG, "adjustLocalOrRemoteStreamVolume() doesn't support stream " + streamType);
@@ -1624,120 +1628,120 @@ public class AudioManager {
     }
 
     /*
-     * Sets a generic audio configuration parameter. The use of these parameters
-     * are platform dependant, see libaudio
-     *
-     * ** Temporary interface - DO NOT USE
-     *
-     * TODO: Replace with a more generic key:value get/set mechanism
-     *
-     * param key   name of parameter to set. Must not be null.
-     * param value value of parameter. Must not be null.
-     */
-    /**
-     * @hide
-     * @deprecated Use {@link #setParameters(String)} instead
-     */
+* Sets a generic audio configuration parameter. The use of these parameters
+* are platform dependant, see libaudio
+*
+* ** Temporary interface - DO NOT USE
+*
+* TODO: Replace with a more generic key:value get/set mechanism
+*
+* param key name of parameter to set. Must not be null.
+* param value value of parameter. Must not be null.
+*/
+    /**
+* @hide
+* @deprecated Use {@link #setParameters(String)} instead
+*/
     @Deprecated public void setParameter(String key, String value) {
         setParameters(key+"="+value);
     }
 
     /**
-     * Sets a variable number of parameter values to audio hardware.
-     *
-     * @param keyValuePairs list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     *
-     */
+* Sets a variable number of parameter values to audio hardware.
+*
+* @param keyValuePairs list of parameters key value pairs in the form:
+* key1=value1;key2=value2;...
+*
+*/
     public void setParameters(String keyValuePairs) {
         AudioSystem.setParameters(keyValuePairs);
     }
 
     /**
-     * Gets a variable number of parameter values from audio hardware.
-     *
-     * @param keys list of parameters
-     * @return list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     */
+* Gets a variable number of parameter values from audio hardware.
+*
+* @param keys list of parameters
+* @return list of parameters key value pairs in the form:
+* key1=value1;key2=value2;...
+*/
     public String getParameters(String keys) {
         return AudioSystem.getParameters(keys);
     }
 
     /* Sound effect identifiers */
     /**
-     * Keyboard and direction pad click sound
-     * @see #playSoundEffect(int)
-     */
+* Keyboard and direction pad click sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEY_CLICK = 0;
     /**
-     * Focus has moved up
-     * @see #playSoundEffect(int)
-     */
+* Focus has moved up
+* @see #playSoundEffect(int)
+*/
     public static final int FX_FOCUS_NAVIGATION_UP = 1;
     /**
-     * Focus has moved down
-     * @see #playSoundEffect(int)
-     */
+* Focus has moved down
+* @see #playSoundEffect(int)
+*/
     public static final int FX_FOCUS_NAVIGATION_DOWN = 2;
     /**
-     * Focus has moved left
-     * @see #playSoundEffect(int)
-     */
+* Focus has moved left
+* @see #playSoundEffect(int)
+*/
     public static final int FX_FOCUS_NAVIGATION_LEFT = 3;
     /**
-     * Focus has moved right
-     * @see #playSoundEffect(int)
-     */
+* Focus has moved right
+* @see #playSoundEffect(int)
+*/
     public static final int FX_FOCUS_NAVIGATION_RIGHT = 4;
     /**
-     * IME standard keypress sound
-     * @see #playSoundEffect(int)
-     */
+* IME standard keypress sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEYPRESS_STANDARD = 5;
     /**
-     * IME spacebar keypress sound
-     * @see #playSoundEffect(int)
-     */
+* IME spacebar keypress sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEYPRESS_SPACEBAR = 6;
     /**
-     * IME delete keypress sound
-     * @see #playSoundEffect(int)
-     */
+* IME delete keypress sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEYPRESS_DELETE = 7;
     /**
-     * IME return_keypress sound
-     * @see #playSoundEffect(int)
-     */
+* IME return_keypress sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEYPRESS_RETURN = 8;
 
     /**
-     * Invalid keypress sound
-     * @see #playSoundEffect(int)
-     */
+* Invalid keypress sound
+* @see #playSoundEffect(int)
+*/
     public static final int FX_KEYPRESS_INVALID = 9;
     /**
-     * @hide Number of sound effects
-     */
+* @hide Number of sound effects
+*/
     public static final int NUM_SOUND_EFFECTS = 10;
 
     /**
-     * Plays a sound effect (Key clicks, lid open/close...)
-     * @param effectType The type of sound effect. One of
-     *            {@link #FX_KEY_CLICK},
-     *            {@link #FX_FOCUS_NAVIGATION_UP},
-     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
-     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
-     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
-     *            {@link #FX_KEYPRESS_STANDARD},
-     *            {@link #FX_KEYPRESS_SPACEBAR},
-     *            {@link #FX_KEYPRESS_DELETE},
-     *            {@link #FX_KEYPRESS_RETURN},
-     *            {@link #FX_KEYPRESS_INVALID},
-     * NOTE: This version uses the UI settings to determine
-     * whether sounds are heard or not.
-     */
-    public void  playSoundEffect(int effectType) {
+* Plays a sound effect (Key clicks, lid open/close...)
+* @param effectType The type of sound effect. One of
+* {@link #FX_KEY_CLICK},
+* {@link #FX_FOCUS_NAVIGATION_UP},
+* {@link #FX_FOCUS_NAVIGATION_DOWN},
+* {@link #FX_FOCUS_NAVIGATION_LEFT},
+* {@link #FX_FOCUS_NAVIGATION_RIGHT},
+* {@link #FX_KEYPRESS_STANDARD},
+* {@link #FX_KEYPRESS_SPACEBAR},
+* {@link #FX_KEYPRESS_DELETE},
+* {@link #FX_KEYPRESS_RETURN},
+* {@link #FX_KEYPRESS_INVALID},
+* NOTE: This version uses the UI settings to determine
+* whether sounds are heard or not.
+*/
+    public void playSoundEffect(int effectType) {
         if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
             return;
         }
@@ -1755,25 +1759,25 @@ public class AudioManager {
     }
 
     /**
-     * Plays a sound effect (Key clicks, lid open/close...)
-     * @param effectType The type of sound effect. One of
-     *            {@link #FX_KEY_CLICK},
-     *            {@link #FX_FOCUS_NAVIGATION_UP},
-     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
-     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
-     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
-     *            {@link #FX_KEYPRESS_STANDARD},
-     *            {@link #FX_KEYPRESS_SPACEBAR},
-     *            {@link #FX_KEYPRESS_DELETE},
-     *            {@link #FX_KEYPRESS_RETURN},
-     *            {@link #FX_KEYPRESS_INVALID},
-     * @param volume Sound effect volume.
-     * The volume value is a raw scalar so UI controls should be scaled logarithmically.
-     * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
-     * NOTE: This version is for applications that have their own
-     * settings panel for enabling and controlling volume.
-     */
-    public void  playSoundEffect(int effectType, float volume) {
+* Plays a sound effect (Key clicks, lid open/close...)
+* @param effectType The type of sound effect. One of
+* {@link #FX_KEY_CLICK},
+* {@link #FX_FOCUS_NAVIGATION_UP},
+* {@link #FX_FOCUS_NAVIGATION_DOWN},
+* {@link #FX_FOCUS_NAVIGATION_LEFT},
+* {@link #FX_FOCUS_NAVIGATION_RIGHT},
+* {@link #FX_KEYPRESS_STANDARD},
+* {@link #FX_KEYPRESS_SPACEBAR},
+* {@link #FX_KEYPRESS_DELETE},
+* {@link #FX_KEYPRESS_RETURN},
+* {@link #FX_KEYPRESS_INVALID},
+* @param volume Sound effect volume.
+* The volume value is a raw scalar so UI controls should be scaled logarithmically.
+* If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
+* NOTE: This version is for applications that have their own
+* settings panel for enabling and controlling volume.
+*/
+    public void playSoundEffect(int effectType, float volume) {
         if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
             return;
         }
@@ -1787,17 +1791,17 @@ public class AudioManager {
     }
 
     /**
-     * Settings has an in memory cache, so this is fast.
-     */
+* Settings has an in memory cache, so this is fast.
+*/
     private boolean querySoundEffectsEnabled() {
         return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
     }
 
 
     /**
-     *  Load Sound effects.
-     *  This method must be called when sound effects are enabled.
-     */
+* Load Sound effects.
+* This method must be called when sound effects are enabled.
+*/
     public void loadSoundEffects() {
         IAudioService service = getService();
         try {
@@ -1808,10 +1812,10 @@ public class AudioManager {
     }
 
     /**
-     *  Unload Sound effects.
-     *  This method can be called to free some memory when
-     *  sound effects are disabled.
-     */
+* Unload Sound effects.
+* This method can be called to free some memory when
+* sound effects are disabled.
+*/
     public void unloadSoundEffects() {
         IAudioService service = getService();
         try {
@@ -1822,93 +1826,93 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Used to indicate no audio focus has been gained or lost.
-     */
+* @hide
+* Used to indicate no audio focus has been gained or lost.
+*/
     public static final int AUDIOFOCUS_NONE = 0;
 
     /**
-     * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
+* Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+* @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+*/
     public static final int AUDIOFOCUS_GAIN = 1;
     /**
-     * Used to indicate a temporary gain or request of audio focus, anticipated to last a short
-     * amount of time. Examples of temporary changes are the playback of driving directions, or an
-     * event notification.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
+* Used to indicate a temporary gain or request of audio focus, anticipated to last a short
+* amount of time. Examples of temporary changes are the playback of driving directions, or an
+* event notification.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+* @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+*/
     public static final int AUDIOFOCUS_GAIN_TRANSIENT = 2;
     /**
-     * Used to indicate a temporary request of audio focus, anticipated to last a short
-     * amount of time, and where it is acceptable for other audio applications to keep playing
-     * after having lowered their output level (also referred to as "ducking").
-     * Examples of temporary changes are the playback of driving directions where playback of music
-     * in the background is acceptable.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
+* Used to indicate a temporary request of audio focus, anticipated to last a short
+* amount of time, and where it is acceptable for other audio applications to keep playing
+* after having lowered their output level (also referred to as "ducking").
+* Examples of temporary changes are the playback of driving directions where playback of music
+* in the background is acceptable.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+* @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+*/
     public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = 3;
     /**
-     * Used to indicate a temporary request of audio focus, anticipated to last a short
-     * amount of time, during which no other applications, or system components, should play
-     * anything. Examples of exclusive and transient audio focus requests are voice
-     * memo recording and speech recognition, during which the system shouldn't play any
-     * notifications, and media playback should have paused.
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
+* Used to indicate a temporary request of audio focus, anticipated to last a short
+* amount of time, during which no other applications, or system components, should play
+* anything. Examples of exclusive and transient audio focus requests are voice
+* memo recording and speech recognition, during which the system shouldn't play any
+* notifications, and media playback should have paused.
+* @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+*/
     public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = 4;
     /**
-     * Used to indicate a loss of audio focus of unknown duration.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
+* Used to indicate a loss of audio focus of unknown duration.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+*/
     public static final int AUDIOFOCUS_LOSS = -1 * AUDIOFOCUS_GAIN;
     /**
-     * Used to indicate a transient loss of audio focus.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
+* Used to indicate a transient loss of audio focus.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+*/
     public static final int AUDIOFOCUS_LOSS_TRANSIENT = -1 * AUDIOFOCUS_GAIN_TRANSIENT;
     /**
-     * Used to indicate a transient loss of audio focus where the loser of the audio focus can
-     * lower its output volume if it wants to continue playing (also referred to as "ducking"), as
-     * the new focus owner doesn't require others to be silent.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
+* Used to indicate a transient loss of audio focus where the loser of the audio focus can
+* lower its output volume if it wants to continue playing (also referred to as "ducking"), as
+* the new focus owner doesn't require others to be silent.
+* @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+*/
     public static final int AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK =
             -1 * AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
 
     /**
-     * Interface definition for a callback to be invoked when the audio focus of the system is
-     * updated.
-     */
+* Interface definition for a callback to be invoked when the audio focus of the system is
+* updated.
+*/
     public interface OnAudioFocusChangeListener {
         /**
-         * Called on the listener to notify it the audio focus for this listener has been changed.
-         * The focusChange value indicates whether the focus was gained,
-         * whether the focus was lost, and whether that loss is transient, or whether the new focus
-         * holder will hold it for an unknown amount of time.
-         * When losing focus, listeners can use the focus change information to decide what
-         * behavior to adopt when losing focus. A music player could for instance elect to lower
-         * the volume of its music stream (duck) for transient focus losses, and pause otherwise.
-         * @param focusChange the type of focus change, one of {@link AudioManager#AUDIOFOCUS_GAIN},
-         *   {@link AudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT}
-         *   and {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}.
-         */
+* Called on the listener to notify it the audio focus for this listener has been changed.
+* The focusChange value indicates whether the focus was gained,
+* whether the focus was lost, and whether that loss is transient, or whether the new focus
+* holder will hold it for an unknown amount of time.
+* When losing focus, listeners can use the focus change information to decide what
+* behavior to adopt when losing focus. A music player could for instance elect to lower
+* the volume of its music stream (duck) for transient focus losses, and pause otherwise.
+* @param focusChange the type of focus change, one of {@link AudioManager#AUDIOFOCUS_GAIN},
+* {@link AudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT}
+* and {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}.
+*/
         public void onAudioFocusChange(int focusChange);
     }
 
     /**
-     * Map to convert focus event listener IDs, as used in the AudioService audio focus stack,
-     * to actual listener objects.
-     */
+* Map to convert focus event listener IDs, as used in the AudioService audio focus stack,
+* to actual listener objects.
+*/
     private final HashMap<String, OnAudioFocusChangeListener> mAudioFocusIdListenerMap =
             new HashMap<String, OnAudioFocusChangeListener>();
     /**
-     * Lock to prevent concurrent changes to the list of focus listeners for this AudioManager
-     * instance.
-     */
+* Lock to prevent concurrent changes to the list of focus listeners for this AudioManager
+* instance.
+*/
     private final Object mFocusListenerLock = new Object();
 
     private OnAudioFocusChangeListener findFocusListener(String id) {
@@ -1916,14 +1920,14 @@ public class AudioManager {
     }
 
     /**
-     * Handler for audio focus events coming from the audio service.
-     */
+* Handler for audio focus events coming from the audio service.
+*/
     private final FocusEventHandlerDelegate mAudioFocusEventHandlerDelegate =
             new FocusEventHandlerDelegate();
 
     /**
-     * Helper class to handle the forwarding of audio focus events to the appropriate listener
-     */
+* Helper class to handle the forwarding of audio focus events to the appropriate listener
+*/
     private class FocusEventHandlerDelegate {
         private final Handler mHandler;
 
@@ -1975,12 +1979,12 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Registers a listener to be called when audio focus changes. Calling this method is optional
-     * before calling {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, as it
-     * will register the listener as well if it wasn't registered already.
-     * @param l the listener to be notified of audio focus changes.
-     */
+* @hide
+* Registers a listener to be called when audio focus changes. Calling this method is optional
+* before calling {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, as it
+* will register the listener as well if it wasn't registered already.
+* @param l the listener to be notified of audio focus changes.
+*/
     public void registerAudioFocusListener(OnAudioFocusChangeListener l) {
         synchronized(mFocusListenerLock) {
             if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
@@ -1991,10 +1995,10 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Causes the specified listener to not be called anymore when focus is gained or lost.
-     * @param l the listener to unregister.
-     */
+* @hide
+* Causes the specified listener to not be called anymore when focus is gained or lost.
+* @param l the listener to unregister.
+*/
     public void unregisterAudioFocusListener(OnAudioFocusChangeListener l) {
 
         // remove locally
@@ -2005,32 +2009,32 @@ public class AudioManager {
 
 
     /**
-     * A failed focus change request.
-     */
+* A failed focus change request.
+*/
     public static final int AUDIOFOCUS_REQUEST_FAILED = 0;
     /**
-     * A successful focus change request.
-     */
+* A successful focus change request.
+*/
     public static final int AUDIOFOCUS_REQUEST_GRANTED = 1;
 
 
     /**
-     *  Request audio focus.
-     *  Send a request to obtain the audio focus
-     *  @param l the listener to be notified of audio focus changes
-     *  @param streamType the main audio stream type affected by the focus request
-     *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
-     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are
-     *      for the playback of driving directions, or notifications sounds.
-     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
-     *      the previous focus owner to keep playing if it ducks its audio output.
-     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request
-     *      that benefits from the system not playing disruptive sounds like notifications, for
-     *      usecases such as voice memo recording, or speech recognition.
-     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
-     *      as the playback of a song or a video.
-     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
-     */
+* Request audio focus.
+* Send a request to obtain the audio focus
+* @param l the listener to be notified of audio focus changes
+* @param streamType the main audio stream type affected by the focus request
+* @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
+* is temporary, and focus will be abandonned shortly. Examples of transient requests are
+* for the playback of driving directions, or notifications sounds.
+* Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
+* the previous focus owner to keep playing if it ducks its audio output.
+* Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request
+* that benefits from the system not playing disruptive sounds like notifications, for
+* usecases such as voice memo recording, or speech recognition.
+* Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
+* as the playback of a song or a video.
+* @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
+*/
     public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) {
         int status = AUDIOFOCUS_REQUEST_FAILED;
         if ((durationHint < AUDIOFOCUS_GAIN) ||
@@ -2052,15 +2056,15 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Used internally by telephony package to request audio focus. Will cause the focus request
-     * to be associated with the "voice communication" identifier only used in AudioService
-     * to identify this use case.
-     * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
-     *    the establishment of the call
-     * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
-     *    media applications resume after a call
-     */
+* @hide
+* Used internally by telephony package to request audio focus. Will cause the focus request
+* to be associated with the "voice communication" identifier only used in AudioService
+* to identify this use case.
+* @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
+* the establishment of the call
+* @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
+* media applications resume after a call
+*/
     public void requestAudioFocusForCall(int streamType, int durationHint) {
         IAudioService service = getService();
         try {
@@ -2073,11 +2077,11 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Used internally by telephony package to abandon audio focus, typically after a call or
-     * when ringing ends and the call is rejected or not answered.
-     * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
-     */
+* @hide
+* Used internally by telephony package to abandon audio focus, typically after a call or
+* when ringing ends and the call is rejected or not answered.
+* Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
+*/
     public void abandonAudioFocusForCall() {
         IAudioService service = getService();
         try {
@@ -2088,10 +2092,10 @@ public class AudioManager {
     }
 
     /**
-     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
-     *  @param l the listener with which focus was requested.
-     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
-     */
+* Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
+* @param l the listener with which focus was requested.
+* @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
+*/
     public int abandonAudioFocus(OnAudioFocusChangeListener l) {
         int status = AUDIOFOCUS_REQUEST_FAILED;
         unregisterAudioFocusListener(l);
@@ -2109,12 +2113,12 @@ public class AudioManager {
     //====================================================================
     // Remote Control
     /**
-     * Register a component to be the sole receiver of MEDIA_BUTTON intents.
-     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
-     *      that will receive the media button intent. This broadcast receiver must be declared
-     *      in the application manifest. The package of the component must match that of
-     *      the context you're registering from.
-     */
+* Register a component to be the sole receiver of MEDIA_BUTTON intents.
+* @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
+* that will receive the media button intent. This broadcast receiver must be declared
+* in the application manifest. The package of the component must match that of
+* the context you're registering from.
+*/
     public void registerMediaButtonEventReceiver(ComponentName eventReceiver) {
         if (eventReceiver == null) {
             return;
@@ -2126,7 +2130,7 @@ public class AudioManager {
         }
         // construct a PendingIntent for the media button and register it
         Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        //     the associated intent will be handled by the component being registered
+        // the associated intent will be handled by the component being registered
         mediaButtonIntent.setComponent(eventReceiver);
         PendingIntent pi = PendingIntent.getBroadcast(mContext,
                 0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
@@ -2134,15 +2138,15 @@ public class AudioManager {
     }
 
     /**
-     * Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like
-     * {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows
-     * the buttons to go to any PendingIntent.  Note that you should only use this form if
-     * you know you will continue running for the full time until unregistering the
-     * PendingIntent.
-     * @param eventReceiver target that will receive media button intents.  The PendingIntent
-     * will be sent as-is when a media button action occurs, with {@link Intent#EXTRA_KEY_EVENT}
-     * added and holding the key code of the media button that was pressed.
-     */
+* Register a component to be the sole receiver of MEDIA_BUTTON intents. This is like
+* {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows
+* the buttons to go to any PendingIntent. Note that you should only use this form if
+* you know you will continue running for the full time until unregistering the
+* PendingIntent.
+* @param eventReceiver target that will receive media button intents. The PendingIntent
+* will be sent as-is when a media button action occurs, with {@link Intent#EXTRA_KEY_EVENT}
+* added and holding the key code of the media button that was pressed.
+*/
     public void registerMediaButtonEventReceiver(PendingIntent eventReceiver) {
         if (eventReceiver == null) {
             return;
@@ -2151,9 +2155,9 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * no-op if (pi == null) or (eventReceiver == null)
-     */
+* @hide
+* no-op if (pi == null) or (eventReceiver == null)
+*/
     public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
         if (pi == null) {
             Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
@@ -2170,11 +2174,11 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Used internally by telephony package to register an intent receiver for ACTION_MEDIA_BUTTON.
-     * @param eventReceiver the component that will receive the media button key events,
-     *          no-op if eventReceiver is null
-     */
+* @hide
+* Used internally by telephony package to register an intent receiver for ACTION_MEDIA_BUTTON.
+* @param eventReceiver the component that will receive the media button key events,
+* no-op if eventReceiver is null
+*/
     public void registerMediaButtonEventReceiverForCalls(ComponentName eventReceiver) {
         if (eventReceiver == null) {
             return;
@@ -2189,8 +2193,8 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public void unregisterMediaButtonEventReceiverForCalls() {
         IAudioService service = getService();
         try {
@@ -2201,17 +2205,17 @@ public class AudioManager {
     }
 
     /**
-     * Unregister the receiver of MEDIA_BUTTON intents.
-     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
-     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.
-     */
+* Unregister the receiver of MEDIA_BUTTON intents.
+* @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
+* that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.
+*/
     public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {
         if (eventReceiver == null) {
             return;
         }
         // construct a PendingIntent for the media button and unregister it
         Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        //     the associated intent will be handled by the component being registered
+        // the associated intent will be handled by the component being registered
         mediaButtonIntent.setComponent(eventReceiver);
         PendingIntent pi = PendingIntent.getBroadcast(mContext,
                 0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
@@ -2219,10 +2223,10 @@ public class AudioManager {
     }
 
     /**
-     * Unregister the receiver of MEDIA_BUTTON intents.
-     * @param eventReceiver same PendingIntent that was registed with
-     *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.
-     */
+* Unregister the receiver of MEDIA_BUTTON intents.
+* @param eventReceiver same PendingIntent that was registed with
+* {@link #registerMediaButtonEventReceiver(PendingIntent)}.
+*/
     public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver) {
         if (eventReceiver == null) {
             return;
@@ -2231,8 +2235,8 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     */
+* @hide
+*/
     public void unregisterMediaButtonIntent(PendingIntent pi) {
         IAudioService service = getService();
         try {
@@ -2243,12 +2247,12 @@ public class AudioManager {
     }
 
     /**
-     * Registers the remote control client for providing information to display on the remote
-     * controls.
-     * @param rcClient The remote control client from which remote controls will receive
-     *      information to display.
-     * @see RemoteControlClient
-     */
+* Registers the remote control client for providing information to display on the remote
+* controls.
+* @param rcClient The remote control client from which remote controls will receive
+* information to display.
+* @see RemoteControlClient
+*/
     public void registerRemoteControlClient(RemoteControlClient rcClient) {
         if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
             return;
@@ -2256,10 +2260,10 @@ public class AudioManager {
         IAudioService service = getService();
         try {
             int rcseId = service.registerRemoteControlClient(
-                    rcClient.getRcMediaIntent(),       /* mediaIntent   */
-                    rcClient.getIRemoteControlClient(),/* rcClient      */
+                    rcClient.getRcMediaIntent(), /* mediaIntent */
+                    rcClient.getIRemoteControlClient(),/* rcClient */
                     // used to match media button event receiver and audio focus
-                    mContext.getPackageName());        /* packageName   */
+                    mContext.getPackageName()); /* packageName */
             rcClient.setRcseId(rcseId);
         } catch (RemoteException e) {
             Log.e(TAG, "Dead object in registerRemoteControlClient"+e);
@@ -2267,35 +2271,35 @@ public class AudioManager {
     }
 
     /**
-     * Unregisters the remote control client that was providing information to display on the
-     * remote controls.
-     * @param rcClient The remote control client to unregister.
-     * @see #registerRemoteControlClient(RemoteControlClient)
-     */
+* Unregisters the remote control client that was providing information to display on the
+* remote controls.
+* @param rcClient The remote control client to unregister.
+* @see #registerRemoteControlClient(RemoteControlClient)
+*/
     public void unregisterRemoteControlClient(RemoteControlClient rcClient) {
         if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
             return;
         }
         IAudioService service = getService();
         try {
-            service.unregisterRemoteControlClient(rcClient.getRcMediaIntent(), /* mediaIntent   */
-                    rcClient.getIRemoteControlClient());                       /* rcClient      */
+            service.unregisterRemoteControlClient(rcClient.getRcMediaIntent(), /* mediaIntent */
+                    rcClient.getIRemoteControlClient()); /* rcClient */
         } catch (RemoteException e) {
             Log.e(TAG, "Dead object in unregisterRemoteControlClient"+e);
         }
     }
 
     /**
-     * Registers a {@link RemoteController} instance for it to receive media metadata updates
-     * and playback state information from applications using {@link RemoteControlClient}, and
-     * control their playback.
-     * <p>Registration requires the {@link OnClientUpdateListener} listener to be one of the
-     * enabled notification listeners (see
-     * {@link android.service.notification.NotificationListenerService}).
-     * @param rctlr the object to register.
-     * @return true if the {@link RemoteController} was successfully registered, false if an
-     *     error occurred, due to an internal system error, or insufficient permissions.
-     */
+* Registers a {@link RemoteController} instance for it to receive media metadata updates
+* and playback state information from applications using {@link RemoteControlClient}, and
+* control their playback.
+* <p>Registration requires the {@link OnClientUpdateListener} listener to be one of the
+* enabled notification listeners (see
+* {@link android.service.notification.NotificationListenerService}).
+* @param rctlr the object to register.
+* @return true if the {@link RemoteController} was successfully registered, false if an
+* error occurred, due to an internal system error, or insufficient permissions.
+*/
     public boolean registerRemoteController(RemoteController rctlr) {
         if (rctlr == null) {
             return false;
@@ -2317,10 +2321,10 @@ public class AudioManager {
     }
 
     /**
-     * Unregisters a {@link RemoteController}, causing it to no longer receive media metadata and
-     * playback state information, and no longer be capable of controlling playback.
-     * @param rctlr the object to unregister.
-     */
+* Unregisters a {@link RemoteController}, causing it to no longer receive media metadata and
+* playback state information, and no longer be capable of controlling playback.
+* @param rctlr the object to unregister.
+*/
     public void unregisterRemoteController(RemoteController rctlr) {
         if (rctlr == null) {
             return;
@@ -2335,31 +2339,31 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Registers a remote control display that will be sent information by remote control clients.
-     * Use this method if your IRemoteControlDisplay is not going to display artwork, otherwise
-     * use {@link #registerRemoteControlDisplay(IRemoteControlDisplay, int, int)} to pass the
-     * artwork size directly, or
-     * {@link #remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay, int, int)} later if artwork
-     * is not yet needed.
-     * <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
-     * @param rcd the IRemoteControlDisplay
-     */
+* @hide
+* Registers a remote control display that will be sent information by remote control clients.
+* Use this method if your IRemoteControlDisplay is not going to display artwork, otherwise
+* use {@link #registerRemoteControlDisplay(IRemoteControlDisplay, int, int)} to pass the
+* artwork size directly, or
+* {@link #remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay, int, int)} later if artwork
+* is not yet needed.
+* <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
+* @param rcd the IRemoteControlDisplay
+*/
     public void registerRemoteControlDisplay(IRemoteControlDisplay rcd) {
         // passing a negative value for art work width and height as they are unknown at this stage
         registerRemoteControlDisplay(rcd, /*w*/-1, /*h*/ -1);
     }
 
     /**
-     * @hide
-     * Registers a remote control display that will be sent information by remote control clients.
-     * <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
-     * @param rcd
-     * @param w the maximum width of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     * @param h the maximum height of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     */
+* @hide
+* Registers a remote control display that will be sent information by remote control clients.
+* <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
+* @param rcd
+* @param w the maximum width of the expected bitmap. Negative values indicate it is
+* useless to send artwork.
+* @param h the maximum height of the expected bitmap. Negative values indicate it is
+* useless to send artwork.
+*/
     public void registerRemoteControlDisplay(IRemoteControlDisplay rcd, int w, int h) {
         if (rcd == null) {
             return;
@@ -2373,10 +2377,10 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Unregisters a remote control display that was sent information by remote control clients.
-     * @param rcd
-     */
+* @hide
+* Unregisters a remote control display that was sent information by remote control clients.
+* @param rcd
+*/
     public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
         if (rcd == null) {
             return;
@@ -2390,14 +2394,14 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Sets the artwork size a remote control display expects when receiving bitmaps.
-     * @param rcd
-     * @param w the maximum width of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     * @param h the maximum height of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     */
+* @hide
+* Sets the artwork size a remote control display expects when receiving bitmaps.
+* @param rcd
+* @param w the maximum width of the expected bitmap. Negative values indicate it is
+* useless to send artwork.
+* @param h the maximum height of the expected bitmap. Negative values indicate it is
+* useless to send artwork.
+*/
     public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
         if (rcd == null) {
             return;
@@ -2411,18 +2415,18 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Controls whether a remote control display needs periodic checks of the RemoteControlClient
-     * playback position to verify that the estimated position has not drifted from the actual
-     * position. By default the check is not performed.
-     * The IRemoteControlDisplay must have been previously registered for this to have any effect.
-     * @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
-     *     or disabled. No effect is null.
-     * @param wantsSync if true, RemoteControlClient instances which expose their playback position
-     *     to the framework will regularly compare the estimated playback position with the actual
-     *     position, and will update the IRemoteControlDisplay implementation whenever a drift is
-     *     detected.
-     */
+* @hide
+* Controls whether a remote control display needs periodic checks of the RemoteControlClient
+* playback position to verify that the estimated position has not drifted from the actual
+* position. By default the check is not performed.
+* The IRemoteControlDisplay must have been previously registered for this to have any effect.
+* @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
+* or disabled. No effect is null.
+* @param wantsSync if true, RemoteControlClient instances which expose their playback position
+* to the framework will regularly compare the estimated playback position with the actual
+* position, and will update the IRemoteControlDisplay implementation whenever a drift is
+* detected.
+*/
     public void remoteControlDisplayWantsPlaybackPositionSync(IRemoteControlDisplay rcd,
             boolean wantsSync) {
         if (rcd == null) {
@@ -2437,12 +2441,12 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Request the user of a RemoteControlClient to seek to the given playback position.
-     * @param generationId the RemoteControlClient generation counter for which this request is
-     *         issued. Requests for an older generation than current one will be ignored.
-     * @param timeMs the time in ms to seek to, must be positive.
-     */
+* @hide
+* Request the user of a RemoteControlClient to seek to the given playback position.
+* @param generationId the RemoteControlClient generation counter for which this request is
+* issued. Requests for an older generation than current one will be ignored.
+* @param timeMs the time in ms to seek to, must be positive.
+*/
     public void setRemoteControlClientPlaybackPosition(int generationId, long timeMs) {
         if (timeMs < 0) {
             return;
@@ -2457,14 +2461,14 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Notify the user of a RemoteControlClient that it should update its metadata with the
-     * new value for the given key.
-     * @param generationId the RemoteControlClient generation counter for which this request is
-     *         issued. Requests for an older generation than current one will be ignored.
-     * @param key the metadata key for which a new value exists
-     * @param value the new metadata value
-     */
+* @hide
+* Notify the user of a RemoteControlClient that it should update its metadata with the
+* new value for the given key.
+* @param generationId the RemoteControlClient generation counter for which this request is
+* issued. Requests for an older generation than current one will be ignored.
+* @param key the metadata key for which a new value exists
+* @param value the new metadata value
+*/
     public void updateRemoteControlClientMetadata(int generationId, int key,
             Rating value) {
         IAudioService service = getService();
@@ -2477,11 +2481,11 @@ public class AudioManager {
     }
 
     /**
-     *  @hide
-     *  Reload audio settings. This method is called by Settings backup
-     *  agent when audio settings are restored and causes the AudioService
-     *  to read and apply restored settings.
-     */
+* @hide
+* Reload audio settings. This method is called by Settings backup
+* agent when audio settings are restored and causes the AudioService
+* to read and apply restored settings.
+*/
     public void reloadAudioSettings() {
         IAudioService service = getService();
         try {
@@ -2492,11 +2496,11 @@ public class AudioManager {
     }
 
     /**
-     * @hide
-     * Notifies AudioService that it is connected to an A2DP device that supports absolute volume,
-     * so that AudioService can send volume change events to the A2DP device, rather than handling
-     * them.
-     */
+* @hide
+* Notifies AudioService that it is connected to an A2DP device that supports absolute volume,
+* so that AudioService can send volume change events to the A2DP device, rather than handling
+* them.
+*/
     public void avrcpSupportsAbsoluteVolume(String address, boolean support) {
         IAudioService service = getService();
         try {
@@ -2507,19 +2511,19 @@ public class AudioManager {
     }
 
      /**
-      * {@hide}
-      */
+* {@hide}
+*/
      private final IBinder mICallBack = new Binder();
 
     /**
-     * Checks whether the phone is in silent mode, with or without vibrate.
-     *
-     * @return true if phone is in silent mode, with or without vibrate.
-     *
-     * @see #getRingerMode()
-     *
-     * @hide pending API Council approval
-     */
+* Checks whether the phone is in silent mode, with or without vibrate.
+*
+* @return true if phone is in silent mode, with or without vibrate.
+*
+* @see #getRingerMode()
+*
+* @hide pending API Council approval
+*/
     public boolean isSilentMode() {
         int ringerMode = getRingerMode();
         boolean silentMode =
@@ -2533,10 +2537,10 @@ public class AudioManager {
     // from AudioManager. AudioSystem is an internal class used by AudioManager and AudioService.
 
     /** {@hide} The audio output device code for the small speaker at the front of the device used
-     *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,
-     *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a
-     *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.
-     */
+* when placing calls. Does not refer to an in-ear headphone without attached microphone,
+* such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a
+* {@link #DEVICE_OUT_WIRED_HEADPHONE}.
+*/
     public static final int DEVICE_OUT_EARPIECE = AudioSystem.DEVICE_OUT_EARPIECE;
     /** {@hide} The audio output device code for the built-in speaker */
     public static final int DEVICE_OUT_SPEAKER = AudioSystem.DEVICE_OUT_SPEAKER;
@@ -2547,8 +2551,8 @@ public class AudioManager {
     /** {@hide} The audio output device code for generic Bluetooth SCO, for voice */
     public static final int DEVICE_OUT_BLUETOOTH_SCO = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
     /** {@hide} The audio output device code for Bluetooth SCO Headset Profile (HSP) and
-     *  Hands-Free Profile (HFP), for voice
-     */
+* Hands-Free Profile (HFP), for voice
+*/
     public static final int DEVICE_OUT_BLUETOOTH_SCO_HEADSET =
             AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
     /** {@hide} The audio output device code for Bluetooth SCO car audio, for voice */
@@ -2565,63 +2569,63 @@ public class AudioManager {
     /** {@hide} The audio output device code for S/PDIF or HDMI */
     public static final int DEVICE_OUT_AUX_DIGITAL = AudioSystem.DEVICE_OUT_AUX_DIGITAL;
     /** {@hide} The audio output device code for an analog wired headset attached via a
-     *  docking station
-     */
+* docking station
+*/
     public static final int DEVICE_OUT_ANLG_DOCK_HEADSET = AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
     /** {@hide} The audio output device code for a digital wired headset attached via a
-     *  docking station
-     */
+* docking station
+*/
     public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET;
     /** {@hide} The audio output device code for a USB audio accessory. The accessory is in USB host
-     * mode and the Android device in USB device mode
-     */
+* mode and the Android device in USB device mode
+*/
     public static final int DEVICE_OUT_USB_ACCESSORY = AudioSystem.DEVICE_OUT_USB_ACCESSORY;
     /** {@hide} The audio output device code for a USB audio device. The device is in USB device
-     * mode and the Android device in USB host mode
-     */
+* mode and the Android device in USB host mode
+*/
     public static final int DEVICE_OUT_USB_DEVICE = AudioSystem.DEVICE_OUT_USB_DEVICE;
     /** {@hide} This is not used as a returned value from {@link #getDevicesForStream}, but could be
-     *  used in the future in a set method to select whatever default device is chosen by the
-     *  platform-specific implementation.
-     */
+* used in the future in a set method to select whatever default device is chosen by the
+* platform-specific implementation.
+*/
     public static final int DEVICE_OUT_DEFAULT = AudioSystem.DEVICE_OUT_DEFAULT;
 
     /**
-     * Return the enabled devices for the specified output stream type.
-     *
-     * @param streamType The stream type to query. One of
-     *            {@link #STREAM_VOICE_CALL},
-     *            {@link #STREAM_SYSTEM},
-     *            {@link #STREAM_RING},
-     *            {@link #STREAM_MUSIC},
-     *            {@link #STREAM_ALARM},
-     *            {@link #STREAM_NOTIFICATION},
-     *            {@link #STREAM_DTMF}.
-     *
-     * @return The bit-mask "or" of audio output device codes for all enabled devices on this
-     *         stream. Zero or more of
-     *            {@link #DEVICE_OUT_EARPIECE},
-     *            {@link #DEVICE_OUT_SPEAKER},
-     *            {@link #DEVICE_OUT_WIRED_HEADSET},
-     *            {@link #DEVICE_OUT_WIRED_HEADPHONE},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},
-     *            {@link #DEVICE_OUT_AUX_DIGITAL},
-     *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},
-     *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.
-     *            {@link #DEVICE_OUT_DEFAULT} is not used here.
-     *
-     * The implementation may support additional device codes beyond those listed, so
-     * the application should ignore any bits which it does not recognize.
-     * Note that the information may be imprecise when the implementation
-     * cannot distinguish whether a particular device is enabled.
-     *
-     * {@hide}
-     */
+* Return the enabled devices for the specified output stream type.
+*
+* @param streamType The stream type to query. One of
+* {@link #STREAM_VOICE_CALL},
+* {@link #STREAM_SYSTEM},
+* {@link #STREAM_RING},
+* {@link #STREAM_MUSIC},
+* {@link #STREAM_ALARM},
+* {@link #STREAM_NOTIFICATION},
+* {@link #STREAM_DTMF}.
+*
+* @return The bit-mask "or" of audio output device codes for all enabled devices on this
+* stream. Zero or more of
+* {@link #DEVICE_OUT_EARPIECE},
+* {@link #DEVICE_OUT_SPEAKER},
+* {@link #DEVICE_OUT_WIRED_HEADSET},
+* {@link #DEVICE_OUT_WIRED_HEADPHONE},
+* {@link #DEVICE_OUT_BLUETOOTH_SCO},
+* {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},
+* {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},
+* {@link #DEVICE_OUT_BLUETOOTH_A2DP},
+* {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},
+* {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},
+* {@link #DEVICE_OUT_AUX_DIGITAL},
+* {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},
+* {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.
+* {@link #DEVICE_OUT_DEFAULT} is not used here.
+*
+* The implementation may support additional device codes beyond those listed, so
+* the application should ignore any bits which it does not recognize.
+* Note that the information may be imprecise when the implementation
+* cannot distinguish whether a particular device is enabled.
+*
+* {@hide}
+*/
     public int getDevicesForStream(int streamType) {
         switch (streamType) {
         case STREAM_VOICE_CALL:
@@ -2638,12 +2642,12 @@ public class AudioManager {
     }
 
      /**
-     * Indicate wired accessory connection state change.
-     * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
-     * @param state  new connection state: 1 connected, 0 disconnected
-     * @param name   device name
-     * {@hide}
-     */
+* Indicate wired accessory connection state change.
+* @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
+* @param state new connection state: 1 connected, 0 disconnected
+* @param name device name
+* {@hide}
+*/
     public void setWiredDeviceConnectionState(int device, int state, String name) {
         IAudioService service = getService();
         try {
@@ -2654,13 +2658,13 @@ public class AudioManager {
     }
 
      /**
-     * Indicate A2DP sink connection state change.
-     * @param device Bluetooth device connected/disconnected
-     * @param state  new connection state (BluetoothProfile.STATE_xxx)
-     * @return a delay in ms that the caller should wait before broadcasting
-     * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
-     * {@hide}
-     */
+* Indicate A2DP sink connection state change.
+* @param device Bluetooth device connected/disconnected
+* @param state new connection state (BluetoothProfile.STATE_xxx)
+* @return a delay in ms that the caller should wait before broadcasting
+* BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
+* {@hide}
+*/
     public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state) {
         IAudioService service = getService();
         int delay = 0;
@@ -2683,27 +2687,27 @@ public class AudioManager {
     }
 
     /**
-     * Used as a key for {@link #getProperty} to request the native or optimal output sample rate
-     * for this device's primary output stream, in decimal Hz.
-     */
+* Used as a key for {@link #getProperty} to request the native or optimal output sample rate
+* for this device's primary output stream, in decimal Hz.
+*/
     public static final String PROPERTY_OUTPUT_SAMPLE_RATE =
             "android.media.property.OUTPUT_SAMPLE_RATE";
 
     /**
-     * Used as a key for {@link #getProperty} to request the native or optimal output buffer size
-     * for this device's primary output stream, in decimal PCM frames.
-     */
+* Used as a key for {@link #getProperty} to request the native or optimal output buffer size
+* for this device's primary output stream, in decimal PCM frames.
+*/
     public static final String PROPERTY_OUTPUT_FRAMES_PER_BUFFER =
             "android.media.property.OUTPUT_FRAMES_PER_BUFFER";
 
     /**
-     * Returns the value of the property with the specified key.
-     * @param key One of the strings corresponding to a property key: either
-     *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
-     *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
-     * @return A string representing the associated value for that property key,
-     *         or null if there is no value for that key.
-     */
+* Returns the value of the property with the specified key.
+* @param key One of the strings corresponding to a property key: either
+* {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
+* {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
+* @return A string representing the associated value for that property key,
+* or null if there is no value for that key.
+*/
     public String getProperty(String key) {
         if (PROPERTY_OUTPUT_SAMPLE_RATE.equals(key)) {
             int outputSampleRate = AudioSystem.getPrimaryOutputSamplingRate();
@@ -2718,12 +2722,12 @@ public class AudioManager {
     }
 
     /**
-     * Returns the estimated latency for the given stream type in milliseconds.
-     *
-     * DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need
-     * a better solution.
-     * @hide
-     */
+* Returns the estimated latency for the given stream type in milliseconds.
+*
+* DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need
+* a better solution.
+* @hide
+*/
     public int getOutputLatency(int streamType) {
         return AudioSystem.getOutputLatency(streamType);
     }
diff --git a/media/java/android/media/AudioService.java b/media/java/android/media/AudioService.java
index 9e8060e..3e3ae7a 100644
--- a/media/java/android/media/AudioService.java
+++ b/media/java/android/media/AudioService.java
@@ -432,8 +432,8 @@ public class AudioService extends IAudioService.Stub {
     // Devices for which the volume is fixed and VolumePanel slider should be disabled
     final int mFixedVolumeDevices = AudioSystem.DEVICE_OUT_AUX_DIGITAL |
             AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
-            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET |
-            AudioSystem.DEVICE_OUT_ALL_USB;
+            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET
+            /*AudioSystem.DEVICE_OUT_ALL_USB*/;
 
     // TODO merge orientation and rotation
     private final boolean mMonitorOrientation;
@@ -2844,6 +2844,7 @@ public class AudioService extends IAudioService.Stub {
     }
 
     public void setWiredDeviceConnectionState(int device, int state, String name) {
+               Log.i(TAG, "setWiredDeviceConnectionState: device="+device+" state="+state+" name="+name);
         synchronized (mConnectedDevices) {
             int delay = checkSendBecomingNoisyIntent(device, state);
             queueMsgUnderWakeLock(mAudioHandler,
@@ -3958,26 +3959,29 @@ public class AudioService extends IAudioService.Stub {
     }
 
     private boolean handleDeviceConnection(boolean connected, int device, String params) {
+        Log.i(TAG, "handleDeviceConnection: connected="+connected+" device="+device+" params="+params);
         synchronized (mConnectedDevices) {
             boolean isConnected = (mConnectedDevices.containsKey(device) &&
                     (params.isEmpty() || mConnectedDevices.get(device).equals(params)));
+               Log.i(TAG, "handleDeviceConnection: connected="+connected+" isConnected="+isConnected+" device="+device+" params="+params);
 
-            if (isConnected && !connected) {
+       if (!connected) {
+                Log.i(TAG, "handleDeviceConnection: setDeviceConnectionState DEVICE_STATE_UNAVAILABLE");
                 AudioSystem.setDeviceConnectionState(device,
                                               AudioSystem.DEVICE_STATE_UNAVAILABLE,
                                               mConnectedDevices.get(device));
                  mConnectedDevices.remove(device);
                  return true;
-            } else if (!isConnected && connected) {
-                 AudioSystem.setDeviceConnectionState(device,
-                                                      AudioSystem.DEVICE_STATE_AVAILABLE,
-                                                      params);
-                 mConnectedDevices.put(new Integer(device), params);
-                 return true;
-            }
+           }
+
+           Log.i(TAG, "handleDeviceConnection: setDeviceConnectionState DEVICE_STATE_AVAILABLE");
+			AudioSystem.setDeviceConnectionState(device,
+                                                  AudioSystem.DEVICE_STATE_AVAILABLE,
+                                                  params);
+            mConnectedDevices.put(new Integer(device), params);
+            return true;
         }
-        return false;
-    }
+     }
 
     // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
     // sent if none of these devices is connected.
@@ -4071,6 +4075,7 @@ public class AudioService extends IAudioService.Stub {
 
     private void onSetWiredDeviceConnectionState(int device, int state, String name)
     {
+        Log.i(TAG, "onSetWiredDeviceConnectionState: device="+device+" state="+state+" name="+name);
         synchronized (mConnectedDevices) {
             if ((state == 0) && ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
                     (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE))) {
@@ -4081,6 +4086,7 @@ public class AudioService extends IAudioService.Stub {
             if (state != 0) {
                 if ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
                     (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE)) {
+                    Log.i(TAG, "onSetWiredDeviceConnectionState: setBluetoothA2dpOnInt(false)");
                     setBluetoothA2dpOnInt(false);
                 }
                 if ((device & mSafeMediaVolumeDevices) != 0) {
@@ -4200,7 +4206,7 @@ public class AudioService extends IAudioService.Stub {
                                     : "card=" + alsaCard + ";device=" + alsaDevice);
                 device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
                         AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
-                Log.v(TAG, "Broadcast Receiver: Got "
+                Log.i(TAG, "Broadcast Receiver: Got "
                         + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
                               "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG")
                         + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
diff --git a/media/java/android/media/AudioTrack.java b/media/java/android/media/AudioTrack.java
index 78a37c5..0f5216f 100644
--- a/media/java/android/media/AudioTrack.java
+++ b/media/java/android/media/AudioTrack.java
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2008 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 package android.media;
 
@@ -25,39 +25,39 @@ import android.util.Log;
 
 
 /**
- * The AudioTrack class manages and plays a single audio resource for Java applications.
- * It allows streaming of PCM audio buffers to the audio sink for playback. This is
- * achieved by "pushing" the data to the AudioTrack object using one of the
- *  {@link #write(byte[], int, int)} and {@link #write(short[], int, int)} methods.
- *
- * <p>An AudioTrack instance can operate under two modes: static or streaming.<br>
- * In Streaming mode, the application writes a continuous stream of data to the AudioTrack, using
- * one of the {@code write()} methods. These are blocking and return when the data has been
- * transferred from the Java layer to the native layer and queued for playback. The streaming
- * mode is most useful when playing blocks of audio data that for instance are:
- *
- * <ul>
- *   <li>too big to fit in memory because of the duration of the sound to play,</li>
- *   <li>too big to fit in memory because of the characteristics of the audio data
- *         (high sampling rate, bits per sample ...)</li>
- *   <li>received or generated while previously queued audio is playing.</li>
- * </ul>
- *
- * The static mode should be chosen when dealing with short sounds that fit in memory and
- * that need to be played with the smallest latency possible. The static mode will
- * therefore be preferred for UI and game sounds that are played often, and with the
- * smallest overhead possible.
- *
- * <p>Upon creation, an AudioTrack object initializes its associated audio buffer.
- * The size of this buffer, specified during the construction, determines how long an AudioTrack
- * can play before running out of data.<br>
- * For an AudioTrack using the static mode, this size is the maximum size of the sound that can
- * be played from it.<br>
- * For the streaming mode, data will be written to the audio sink in chunks of
- * sizes less than or equal to the total buffer size.
- *
- * AudioTrack is not final and thus permits subclasses, but such use is not recommended.
- */
+* The AudioTrack class manages and plays a single audio resource for Java applications.
+* It allows streaming of PCM audio buffers to the audio sink for playback. This is
+* achieved by "pushing" the data to the AudioTrack object using one of the
+* {@link #write(byte[], int, int)} and {@link #write(short[], int, int)} methods.
+*
+* <p>An AudioTrack instance can operate under two modes: static or streaming.<br>
+* In Streaming mode, the application writes a continuous stream of data to the AudioTrack, using
+* one of the {@code write()} methods. These are blocking and return when the data has been
+* transferred from the Java layer to the native layer and queued for playback. The streaming
+* mode is most useful when playing blocks of audio data that for instance are:
+*
+* <ul>
+* <li>too big to fit in memory because of the duration of the sound to play,</li>
+* <li>too big to fit in memory because of the characteristics of the audio data
+* (high sampling rate, bits per sample ...)</li>
+* <li>received or generated while previously queued audio is playing.</li>
+* </ul>
+*
+* The static mode should be chosen when dealing with short sounds that fit in memory and
+* that need to be played with the smallest latency possible. The static mode will
+* therefore be preferred for UI and game sounds that are played often, and with the
+* smallest overhead possible.
+*
+* <p>Upon creation, an AudioTrack object initializes its associated audio buffer.
+* The size of this buffer, specified during the construction, determines how long an AudioTrack
+* can play before running out of data.<br>
+* For an AudioTrack using the static mode, this size is the maximum size of the sound that can
+* be played from it.<br>
+* For the streaming mode, data will be written to the audio sink in chunks of
+* sizes less than or equal to the total buffer size.
+*
+* AudioTrack is not final and thus permits subclasses, but such use is not recommended.
+*/
 public class AudioTrack
 {
     //---------------------------------------------------------
@@ -74,72 +74,72 @@ public class AudioTrack
     private static final int SAMPLE_RATE_HZ_MAX = 48000;
 
     /** indicates AudioTrack state is stopped */
-    public static final int PLAYSTATE_STOPPED = 1;  // matches SL_PLAYSTATE_STOPPED
+    public static final int PLAYSTATE_STOPPED = 1; // matches SL_PLAYSTATE_STOPPED
     /** indicates AudioTrack state is paused */
-    public static final int PLAYSTATE_PAUSED  = 2;  // matches SL_PLAYSTATE_PAUSED
+    public static final int PLAYSTATE_PAUSED = 2; // matches SL_PLAYSTATE_PAUSED
     /** indicates AudioTrack state is playing */
-    public static final int PLAYSTATE_PLAYING = 3;  // matches SL_PLAYSTATE_PLAYING
+    public static final int PLAYSTATE_PLAYING = 3; // matches SL_PLAYSTATE_PLAYING
 
     // keep these values in sync with android_media_AudioTrack.cpp
     /**
-     * Creation mode where audio data is transferred from Java to the native layer
-     * only once before the audio starts playing.
-     */
+* Creation mode where audio data is transferred from Java to the native layer
+* only once before the audio starts playing.
+*/
     public static final int MODE_STATIC = 0;
     /**
-     * Creation mode where audio data is streamed from Java to the native layer
-     * as the audio is playing.
-     */
+* Creation mode where audio data is streamed from Java to the native layer
+* as the audio is playing.
+*/
     public static final int MODE_STREAM = 1;
 
     /**
-     * State of an AudioTrack that was not successfully initialized upon creation.
-     */
+* State of an AudioTrack that was not successfully initialized upon creation.
+*/
     public static final int STATE_UNINITIALIZED = 0;
     /**
-     * State of an AudioTrack that is ready to be used.
-     */
-    public static final int STATE_INITIALIZED   = 1;
+* State of an AudioTrack that is ready to be used.
+*/
+    public static final int STATE_INITIALIZED = 1;
     /**
-     * State of a successfully initialized AudioTrack that uses static data,
-     * but that hasn't received that data yet.
-     */
+* State of a successfully initialized AudioTrack that uses static data,
+* but that hasn't received that data yet.
+*/
     public static final int STATE_NO_STATIC_DATA = 2;
 
     // Error codes:
     // to keep in sync with frameworks/base/core/jni/android_media_AudioTrack.cpp
     /**
-     * Denotes a successful operation.
-     */
-    public  static final int SUCCESS                               = 0;
+* Denotes a successful operation.
+*/
+    public static final int SUCCESS = 0;
     /**
-     * Denotes a generic operation failure.
-     */
-    public  static final int ERROR                                 = -1;
+* Denotes a generic operation failure.
+*/
+    public static final int ERROR = -1;
     /**
-     * Denotes a failure due to the use of an invalid value.
-     */
-    public  static final int ERROR_BAD_VALUE                       = -2;
+* Denotes a failure due to the use of an invalid value.
+*/
+    public static final int ERROR_BAD_VALUE = -2;
     /**
-     * Denotes a failure due to the improper use of a method.
-     */
-    public  static final int ERROR_INVALID_OPERATION               = -3;
+* Denotes a failure due to the improper use of a method.
+*/
+    public static final int ERROR_INVALID_OPERATION = -3;
 
-    private static final int ERROR_NATIVESETUP_AUDIOSYSTEM         = -16;
-    private static final int ERROR_NATIVESETUP_INVALIDCHANNELMASK  = -17;
-    private static final int ERROR_NATIVESETUP_INVALIDFORMAT       = -18;
-    private static final int ERROR_NATIVESETUP_INVALIDSTREAMTYPE   = -19;
-    private static final int ERROR_NATIVESETUP_NATIVEINITFAILED    = -20;
+    private static final int ERROR_NATIVESETUP_AUDIOSYSTEM = -16;
+    private static final int ERROR_NATIVESETUP_INVALIDCHANNELMASK = -17;
+    private static final int ERROR_NATIVESETUP_INVALIDFORMAT = -18;
+    private static final int ERROR_NATIVESETUP_INVALIDSTREAMTYPE = -19;
+    private static final int ERROR_NATIVESETUP_NATIVEINITFAILED = -20;
 
     // Events:
     // to keep in sync with frameworks/av/include/media/AudioTrack.h
     /**
-     * Event id denotes when playback head has reached a previously set marker.
-     */
-    private static final int NATIVE_EVENT_MARKER  = 3;
+* Event id denotes when playback head has reached a previously set marker.
+*/
+    private static final int NATIVE_EVENT_MARKER = 3;
     /**
-     * Event id denotes when previously set update period has elapsed during playback.
-     */
+* Event id denotes when previously set update period has elapsed during playback.
+*/
     private static final int NATIVE_EVENT_NEW_POS = 4;
 
     private final static String TAG = "android.media.AudioTrack";
@@ -149,68 +149,68 @@ public class AudioTrack
     // Member variables
     //--------------------
     /**
-     * Indicates the state of the AudioTrack instance.
-     */
+* Indicates the state of the AudioTrack instance.
+*/
     private int mState = STATE_UNINITIALIZED;
     /**
-     * Indicates the play state of the AudioTrack instance.
-     */
+* Indicates the play state of the AudioTrack instance.
+*/
     private int mPlayState = PLAYSTATE_STOPPED;
     /**
-     * Lock to make sure mPlayState updates are reflecting the actual state of the object.
-     */
+* Lock to make sure mPlayState updates are reflecting the actual state of the object.
+*/
     private final Object mPlayStateLock = new Object();
     /**
-     * Sizes of the native audio buffer.
-     */
+* Sizes of the native audio buffer.
+*/
     private int mNativeBufferSizeInBytes = 0;
     private int mNativeBufferSizeInFrames = 0;
     /**
-     * Handler for events coming from the native code.
-     */
+* Handler for events coming from the native code.
+*/
     private NativeEventHandlerDelegate mEventHandlerDelegate;
     /**
-     * Looper associated with the thread that creates the AudioTrack instance.
-     */
+* Looper associated with the thread that creates the AudioTrack instance.
+*/
     private final Looper mInitializationLooper;
     /**
-     * The audio data source sampling rate in Hz.
-     */
+* The audio data source sampling rate in Hz.
+*/
     private int mSampleRate; // initialized by all constructors
     /**
-     * The number of audio output channels (1 is mono, 2 is stereo).
-     */
+* The number of audio output channels (1 is mono, 2 is stereo).
+*/
     private int mChannelCount = 1;
     /**
-     * The audio channel mask.
-     */
+* The audio channel mask.
+*/
     private int mChannels = AudioFormat.CHANNEL_OUT_MONO;
 
     /**
-     * The type of the audio stream to play. See
-     *   {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
-     *   {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
-     *   {@link AudioManager#STREAM_ALARM}, {@link AudioManager#STREAM_NOTIFICATION}, and
-     *   {@link AudioManager#STREAM_DTMF}.
-     */
+* The type of the audio stream to play. See
+* {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
+* {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
+* {@link AudioManager#STREAM_ALARM}, {@link AudioManager#STREAM_NOTIFICATION}, and
+* {@link AudioManager#STREAM_DTMF}.
+*/
     private int mStreamType = AudioManager.STREAM_MUSIC;
     /**
-     * The way audio is consumed by the audio sink, streaming or static.
-     */
+* The way audio is consumed by the audio sink, streaming or static.
+*/
     private int mDataLoadMode = MODE_STREAM;
     /**
-     * The current audio channel configuration.
-     */
+* The current audio channel configuration.
+*/
     private int mChannelConfiguration = AudioFormat.CHANNEL_OUT_MONO;
     /**
-     * The encoding of the audio samples.
-     * @see AudioFormat#ENCODING_PCM_8BIT
-     * @see AudioFormat#ENCODING_PCM_16BIT
-     */
+* The encoding of the audio samples.
+* @see AudioFormat#ENCODING_PCM_8BIT
+* @see AudioFormat#ENCODING_PCM_16BIT
+*/
     private int mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
     /**
-     * Audio session ID
-     */
+* Audio session ID
+*/
     private int mSessionId = 0;
 
 
@@ -218,14 +218,14 @@ public class AudioTrack
     // Used exclusively by native code
     //--------------------
     /**
-     * Accessed by native methods: provides access to C++ AudioTrack object.
-     */
+* Accessed by native methods: provides access to C++ AudioTrack object.
+*/
     @SuppressWarnings("unused")
     private int mNativeTrackInJavaObj;
     /**
-     * Accessed by native methods: provides access to the JNI data (i.e. resources used by
-     * the native AudioTrack object, but not stored in it).
-     */
+* Accessed by native methods: provides access to the JNI data (i.e. resources used by
+* the native AudioTrack object, but not stored in it).
+*/
     @SuppressWarnings("unused")
     private int mJniData;
 
@@ -234,31 +234,31 @@ public class AudioTrack
     // Constructor, Finalize
     //--------------------
     /**
-     * Class constructor.
-     * @param streamType the type of the audio stream. See
-     *   {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
-     *   {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
-     *   {@link AudioManager#STREAM_ALARM}, and {@link AudioManager#STREAM_NOTIFICATION}.
-     * @param sampleRateInHz the initial source sample rate expressed in Hz.
-     * @param channelConfig describes the configuration of the audio channels.
-     *   See {@link AudioFormat#CHANNEL_OUT_MONO} and
-     *   {@link AudioFormat#CHANNEL_OUT_STEREO}
-     * @param audioFormat the format in which the audio data is represented.
-     *   See {@link AudioFormat#ENCODING_PCM_16BIT} and
-     *   {@link AudioFormat#ENCODING_PCM_8BIT}
-     * @param bufferSizeInBytes the total size (in bytes) of the internal buffer where audio data is
-     *   read from for playback.
-     *   If track's creation mode is {@link #MODE_STREAM}, you can write data into
-     *   this buffer in chunks less than or equal to this size, and it is typical to use
-     *   chunks of 1/2 of the total size to permit double-buffering.
-     *   If the track's creation mode is {@link #MODE_STATIC},
-     *   this is the maximum length sample, or audio clip, that can be played by this instance.
-     *   See {@link #getMinBufferSize(int, int, int)} to determine the minimum required buffer size
-     *   for the successful creation of an AudioTrack instance in streaming mode. Using values
-     *   smaller than getMinBufferSize() will result in an initialization failure.
-     * @param mode streaming or static buffer. See {@link #MODE_STATIC} and {@link #MODE_STREAM}
-     * @throws java.lang.IllegalArgumentException
-     */
+* Class constructor.
+* @param streamType the type of the audio stream. See
+* {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
+* {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
+* {@link AudioManager#STREAM_ALARM}, and {@link AudioManager#STREAM_NOTIFICATION}.
+* @param sampleRateInHz the initial source sample rate expressed in Hz.
+* @param channelConfig describes the configuration of the audio channels.
+* See {@link AudioFormat#CHANNEL_OUT_MONO} and
+* {@link AudioFormat#CHANNEL_OUT_STEREO}
+* @param audioFormat the format in which the audio data is represented.
+* See {@link AudioFormat#ENCODING_PCM_16BIT} and
+* {@link AudioFormat#ENCODING_PCM_8BIT}
+* @param bufferSizeInBytes the total size (in bytes) of the internal buffer where audio data is
+* read from for playback.
+* If track's creation mode is {@link #MODE_STREAM}, you can write data into
+* this buffer in chunks less than or equal to this size, and it is typical to use
+* chunks of 1/2 of the total size to permit double-buffering.
+* If the track's creation mode is {@link #MODE_STATIC},
+* this is the maximum length sample, or audio clip, that can be played by this instance.
+* See {@link #getMinBufferSize(int, int, int)} to determine the minimum required buffer size
+* for the successful creation of an AudioTrack instance in streaming mode. Using values
+* smaller than getMinBufferSize() will result in an initialization failure.
+* @param mode streaming or static buffer. See {@link #MODE_STATIC} and {@link #MODE_STREAM}
+* @throws java.lang.IllegalArgumentException
+*/
     public AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat,
             int bufferSizeInBytes, int mode)
     throws IllegalArgumentException {
@@ -267,39 +267,39 @@ public class AudioTrack
     }
 
     /**
-     * Class constructor with audio session. Use this constructor when the AudioTrack must be
-     * attached to a particular audio session. The primary use of the audio session ID is to
-     * associate audio effects to a particular instance of AudioTrack: if an audio session ID
-     * is provided when creating an AudioEffect, this effect will be applied only to audio tracks
-     * and media players in the same session and not to the output mix.
-     * When an AudioTrack is created without specifying a session, it will create its own session
-     * which can be retrieved by calling the {@link #getAudioSessionId()} method.
-     * If a non-zero session ID is provided, this AudioTrack will share effects attached to this
-     * session
-     * with all other media players or audio tracks in the same session, otherwise a new session
-     * will be created for this track if none is supplied.
-     * @param streamType the type of the audio stream. See
-     *   {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
-     *   {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
-     *   {@link AudioManager#STREAM_ALARM}, and {@link AudioManager#STREAM_NOTIFICATION}.
-     * @param sampleRateInHz the initial source sample rate expressed in Hz.
-     * @param channelConfig describes the configuration of the audio channels.
-     *   See {@link AudioFormat#CHANNEL_OUT_MONO} and
-     *   {@link AudioFormat#CHANNEL_OUT_STEREO}
-     * @param audioFormat the format in which the audio data is represented.
-     *   See {@link AudioFormat#ENCODING_PCM_16BIT} and
-     *   {@link AudioFormat#ENCODING_PCM_8BIT}
-     * @param bufferSizeInBytes the total size (in bytes) of the buffer where audio data is read
-     *   from for playback. If using the AudioTrack in streaming mode, you can write data into
-     *   this buffer in smaller chunks than this size. If using the AudioTrack in static mode,
-     *   this is the maximum size of the sound that will be played for this instance.
-     *   See {@link #getMinBufferSize(int, int, int)} to determine the minimum required buffer size
-     *   for the successful creation of an AudioTrack instance in streaming mode. Using values
-     *   smaller than getMinBufferSize() will result in an initialization failure.
-     * @param mode streaming or static buffer. See {@link #MODE_STATIC} and {@link #MODE_STREAM}
-     * @param sessionId Id of audio session the AudioTrack must be attached to
-     * @throws java.lang.IllegalArgumentException
-     */
+* Class constructor with audio session. Use this constructor when the AudioTrack must be
+* attached to a particular audio session. The primary use of the audio session ID is to
+* associate audio effects to a particular instance of AudioTrack: if an audio session ID
+* is provided when creating an AudioEffect, this effect will be applied only to audio tracks
+* and media players in the same session and not to the output mix.
+* When an AudioTrack is created without specifying a session, it will create its own session
+* which can be retrieved by calling the {@link #getAudioSessionId()} method.
+* If a non-zero session ID is provided, this AudioTrack will share effects attached to this
+* session
+* with all other media players or audio tracks in the same session, otherwise a new session
+* will be created for this track if none is supplied.
+* @param streamType the type of the audio stream. See
+* {@link AudioManager#STREAM_VOICE_CALL}, {@link AudioManager#STREAM_SYSTEM},
+* {@link AudioManager#STREAM_RING}, {@link AudioManager#STREAM_MUSIC},
+* {@link AudioManager#STREAM_ALARM}, and {@link AudioManager#STREAM_NOTIFICATION}.
+* @param sampleRateInHz the initial source sample rate expressed in Hz.
+* @param channelConfig describes the configuration of the audio channels.
+* See {@link AudioFormat#CHANNEL_OUT_MONO} and
+* {@link AudioFormat#CHANNEL_OUT_STEREO}
+* @param audioFormat the format in which the audio data is represented.
+* See {@link AudioFormat#ENCODING_PCM_16BIT} and
+* {@link AudioFormat#ENCODING_PCM_8BIT}
+* @param bufferSizeInBytes the total size (in bytes) of the buffer where audio data is read
+* from for playback. If using the AudioTrack in streaming mode, you can write data into
+* this buffer in smaller chunks than this size. If using the AudioTrack in static mode,
+* this is the maximum size of the sound that will be played for this instance.
+* See {@link #getMinBufferSize(int, int, int)} to determine the minimum required buffer size
+* for the successful creation of an AudioTrack instance in streaming mode. Using values
+* smaller than getMinBufferSize() will result in an initialization failure.
+* @param mode streaming or static buffer. See {@link #MODE_STATIC} and {@link #MODE_STREAM}
+* @param sessionId Id of audio session the AudioTrack must be attached to
+* @throws java.lang.IllegalArgumentException
+*/
     public AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat,
             int bufferSizeInBytes, int mode, int sessionId)
     throws IllegalArgumentException {
@@ -353,12 +353,12 @@ public class AudioTrack
     // Convenience method for the constructor's parameter checks.
     // This is where constructor IllegalArgumentException-s are thrown
     // postconditions:
-    //    mStreamType is valid
-    //    mChannelCount is valid
-    //    mChannels is valid
-    //    mAudioFormat is valid
-    //    mSampleRate is valid
-    //    mDataLoadMode is valid
+    // mStreamType is valid
+    // mChannelCount is valid
+    // mChannels is valid
+    // mAudioFormat is valid
+    // mSampleRate is valid
+    // mDataLoadMode is valid
     private void audioParamCheck(int streamType, int sampleRateInHz,
                                  int channelConfig, int audioFormat, int mode) {
 
@@ -431,10 +431,10 @@ public class AudioTrack
     }
 
     /**
-     * Convenience method to check that the channel configuration (a.k.a channel mask) is supported
-     * @param channelConfig the mask to validate
-     * @return false if the AudioTrack can't be used with such a mask
-     */
+* Convenience method to check that the channel configuration (a.k.a channel mask) is supported
+* @param channelConfig the mask to validate
+* @return false if the AudioTrack can't be used with such a mask
+*/
     private static boolean isMultichannelConfigSupported(int channelConfig) {
         // check for unsupported channels
         if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
@@ -464,13 +464,13 @@ public class AudioTrack
 
     // Convenience method for the constructor's audio buffer size check.
     // preconditions:
-    //    mChannelCount is valid
-    //    mAudioFormat is valid
+    // mChannelCount is valid
+    // mAudioFormat is valid
     // postcondition:
-    //    mNativeBufferSizeInBytes is valid (multiple of frame size, positive)
+    // mNativeBufferSizeInBytes is valid (multiple of frame size, positive)
     private void audioBuffSizeCheck(int audioBufferSize) {
         // NB: this section is only valid with PCM data.
-        //     To update when supporting compressed formats
+        // To update when supporting compressed formats
         int frameSizeInBytes = mChannelCount
                 * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
         if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
@@ -483,8 +483,8 @@ public class AudioTrack
 
 
     /**
-     * Releases the native AudioTrack resources.
-     */
+* Releases the native AudioTrack resources.
+*/
     public void release() {
         // even though native_release() stops the native AudioTrack, we need to stop
         // AudioTrack subclasses too.
@@ -506,90 +506,90 @@ public class AudioTrack
     // Getters
     //--------------------
     /**
-     * Returns the minimum valid volume value. Volume values set under this one will
-     * be clamped at this value.
-     * @return the minimum volume expressed as a linear attenuation.
-     */
+* Returns the minimum valid volume value. Volume values set under this one will
+* be clamped at this value.
+* @return the minimum volume expressed as a linear attenuation.
+*/
     static public float getMinVolume() {
         return VOLUME_MIN;
     }
 
     /**
-     * Returns the maximum valid volume value. Volume values set above this one will
-     * be clamped at this value.
-     * @return the maximum volume expressed as a linear attenuation.
-     */
+* Returns the maximum valid volume value. Volume values set above this one will
+* be clamped at this value.
+* @return the maximum volume expressed as a linear attenuation.
+*/
     static public float getMaxVolume() {
         return VOLUME_MAX;
     }
 
     /**
-     * Returns the configured audio data sample rate in Hz
-     */
+* Returns the configured audio data sample rate in Hz
+*/
     public int getSampleRate() {
         return mSampleRate;
     }
 
     /**
-     * Returns the current playback rate in Hz.
-     */
+* Returns the current playback rate in Hz.
+*/
     public int getPlaybackRate() {
         return native_get_playback_rate();
     }
 
     /**
-     * Returns the configured audio data format. See {@link AudioFormat#ENCODING_PCM_16BIT}
-     * and {@link AudioFormat#ENCODING_PCM_8BIT}.
-     */
+* Returns the configured audio data format. See {@link AudioFormat#ENCODING_PCM_16BIT}
+* and {@link AudioFormat#ENCODING_PCM_8BIT}.
+*/
     public int getAudioFormat() {
         return mAudioFormat;
     }
 
     /**
-     * Returns the type of audio stream this AudioTrack is configured for.
-     * Compare the result against {@link AudioManager#STREAM_VOICE_CALL},
-     * {@link AudioManager#STREAM_SYSTEM}, {@link AudioManager#STREAM_RING},
-     * {@link AudioManager#STREAM_MUSIC}, {@link AudioManager#STREAM_ALARM},
-     * {@link AudioManager#STREAM_NOTIFICATION}, or {@link AudioManager#STREAM_DTMF}.
-     */
+* Returns the type of audio stream this AudioTrack is configured for.
+* Compare the result against {@link AudioManager#STREAM_VOICE_CALL},
+* {@link AudioManager#STREAM_SYSTEM}, {@link AudioManager#STREAM_RING},
+* {@link AudioManager#STREAM_MUSIC}, {@link AudioManager#STREAM_ALARM},
+* {@link AudioManager#STREAM_NOTIFICATION}, or {@link AudioManager#STREAM_DTMF}.
+*/
     public int getStreamType() {
         return mStreamType;
     }
 
     /**
-     * Returns the configured channel configuration.
-     * See {@link AudioFormat#CHANNEL_OUT_MONO}
-     * and {@link AudioFormat#CHANNEL_OUT_STEREO}.
-     */
+* Returns the configured channel configuration.
+* See {@link AudioFormat#CHANNEL_OUT_MONO}
+* and {@link AudioFormat#CHANNEL_OUT_STEREO}.
+*/
     public int getChannelConfiguration() {
         return mChannelConfiguration;
     }
 
     /**
-     * Returns the configured number of channels.
-     */
+* Returns the configured number of channels.
+*/
     public int getChannelCount() {
         return mChannelCount;
     }
 
     /**
-     * Returns the state of the AudioTrack instance. This is useful after the
-     * AudioTrack instance has been created to check if it was initialized
-     * properly. This ensures that the appropriate resources have been acquired.
-     * @see #STATE_INITIALIZED
-     * @see #STATE_NO_STATIC_DATA
-     * @see #STATE_UNINITIALIZED
-     */
+* Returns the state of the AudioTrack instance. This is useful after the
+* AudioTrack instance has been created to check if it was initialized
+* properly. This ensures that the appropriate resources have been acquired.
+* @see #STATE_INITIALIZED
+* @see #STATE_NO_STATIC_DATA
+* @see #STATE_UNINITIALIZED
+*/
     public int getState() {
         return mState;
     }
 
     /**
-     * Returns the playback state of the AudioTrack instance.
-     * @see #PLAYSTATE_STOPPED
-     * @see #PLAYSTATE_PAUSED
-     * @see #PLAYSTATE_PLAYING
-     */
+* Returns the playback state of the AudioTrack instance.
+* @see #PLAYSTATE_STOPPED
+* @see #PLAYSTATE_PAUSED
+* @see #PLAYSTATE_PLAYING
+*/
     public int getPlayState() {
         synchronized (mPlayStateLock) {
             return mPlayState;
@@ -597,89 +597,89 @@ public class AudioTrack
     }
 
     /**
-     *  Returns the "native frame count", derived from the bufferSizeInBytes specified at
-     *  creation time and converted to frame units.
-     *  If track's creation mode is {@link #MODE_STATIC},
-     *  it is equal to the specified bufferSizeInBytes converted to frame units.
-     *  If track's creation mode is {@link #MODE_STREAM},
-     *  it is typically greater than or equal to the specified bufferSizeInBytes converted to frame
-     *  units; it may be rounded up to a larger value if needed by the target device implementation.
-     *  @deprecated Only accessible by subclasses, which are not recommended for AudioTrack.
-     *  See {@link AudioManager#getProperty(String)} for key
-     *  {@link AudioManager#PROPERTY_OUTPUT_FRAMES_PER_BUFFER}.
-     */
+* Returns the "native frame count", derived from the bufferSizeInBytes specified at
+* creation time and converted to frame units.
+* If track's creation mode is {@link #MODE_STATIC},
+* it is equal to the specified bufferSizeInBytes converted to frame units.
+* If track's creation mode is {@link #MODE_STREAM},
+* it is typically greater than or equal to the specified bufferSizeInBytes converted to frame
+* units; it may be rounded up to a larger value if needed by the target device implementation.
+* @deprecated Only accessible by subclasses, which are not recommended for AudioTrack.
+* See {@link AudioManager#getProperty(String)} for key
+* {@link AudioManager#PROPERTY_OUTPUT_FRAMES_PER_BUFFER}.
+*/
     @Deprecated
     protected int getNativeFrameCount() {
         return native_get_native_frame_count();
     }
 
     /**
-     * Returns marker position expressed in frames.
-     * @return marker position in wrapping frame units similar to {@link #getPlaybackHeadPosition},
-     * or zero if marker is disabled.
-     */
+* Returns marker position expressed in frames.
+* @return marker position in wrapping frame units similar to {@link #getPlaybackHeadPosition},
+* or zero if marker is disabled.
+*/
     public int getNotificationMarkerPosition() {
         return native_get_marker_pos();
     }
 
     /**
-     * Returns the notification update period expressed in frames.
-     * Zero means that no position update notifications are being delivered.
-     */
+* Returns the notification update period expressed in frames.
+* Zero means that no position update notifications are being delivered.
+*/
     public int getPositionNotificationPeriod() {
         return native_get_pos_update_period();
     }
 
     /**
-     * Returns the playback head position expressed in frames.
-     * Though the "int" type is signed 32-bits, the value should be reinterpreted as if it is
-     * unsigned 32-bits.  That is, the next position after 0x7FFFFFFF is (int) 0x80000000.
-     * This is a continuously advancing counter.  It will wrap (overflow) periodically,
-     * for example approximately once every 27:03:11 hours:minutes:seconds at 44.1 kHz.
-     * It is reset to zero by flush(), reload(), and stop().
-     */
+* Returns the playback head position expressed in frames.
+* Though the "int" type is signed 32-bits, the value should be reinterpreted as if it is
+* unsigned 32-bits. That is, the next position after 0x7FFFFFFF is (int) 0x80000000.
+* This is a continuously advancing counter. It will wrap (overflow) periodically,
+* for example approximately once every 27:03:11 hours:minutes:seconds at 44.1 kHz.
+* It is reset to zero by flush(), reload(), and stop().
+*/
     public int getPlaybackHeadPosition() {
         return native_get_position();
     }
 
     /**
-     * Returns this track's estimated latency in milliseconds. This includes the latency due
-     * to AudioTrack buffer size, AudioMixer (if any) and audio hardware driver.
-     *
-     * DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need
-     * a better solution.
-     * @hide
-     */
+* Returns this track's estimated latency in milliseconds. This includes the latency due
+* to AudioTrack buffer size, AudioMixer (if any) and audio hardware driver.
+*
+* DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need
+* a better solution.
+* @hide
+*/
     public int getLatency() {
         return native_get_latency();
     }
 
     /**
-     *  Returns the output sample rate in Hz for the specified stream type.
-     */
+* Returns the output sample rate in Hz for the specified stream type.
+*/
     static public int getNativeOutputSampleRate(int streamType) {
         return native_get_output_sample_rate(streamType);
     }
 
     /**
-     * Returns the minimum buffer size required for the successful creation of an AudioTrack
-     * object to be created in the {@link #MODE_STREAM} mode. Note that this size doesn't
-     * guarantee a smooth playback under load, and higher values should be chosen according to
-     * the expected frequency at which the buffer will be refilled with additional data to play.
-     * For example, if you intend to dynamically set the source sample rate of an AudioTrack
-     * to a higher value than the initial source sample rate, be sure to configure the buffer size
-     * based on the highest planned sample rate.
-     * @param sampleRateInHz the source sample rate expressed in Hz.
-     * @param channelConfig describes the configuration of the audio channels.
-     *   See {@link AudioFormat#CHANNEL_OUT_MONO} and
-     *   {@link AudioFormat#CHANNEL_OUT_STEREO}
-     * @param audioFormat the format in which the audio data is represented.
-     *   See {@link AudioFormat#ENCODING_PCM_16BIT} and
-     *   {@link AudioFormat#ENCODING_PCM_8BIT}
-     * @return {@link #ERROR_BAD_VALUE} if an invalid parameter was passed,
-     *   or {@link #ERROR} if unable to query for output properties,
-     *   or the minimum buffer size expressed in bytes.
-     */
+* Returns the minimum buffer size required for the successful creation of an AudioTrack
+* object to be created in the {@link #MODE_STREAM} mode. Note that this size doesn't
+* guarantee a smooth playback under load, and higher values should be chosen according to
+* the expected frequency at which the buffer will be refilled with additional data to play.
+* For example, if you intend to dynamically set the source sample rate of an AudioTrack
+* to a higher value than the initial source sample rate, be sure to configure the buffer size
+* based on the highest planned sample rate.
+* @param sampleRateInHz the source sample rate expressed in Hz.
+* @param channelConfig describes the configuration of the audio channels.
+* See {@link AudioFormat#CHANNEL_OUT_MONO} and
+* {@link AudioFormat#CHANNEL_OUT_STEREO}
+* @param audioFormat the format in which the audio data is represented.
+* See {@link AudioFormat#ENCODING_PCM_16BIT} and
+* {@link AudioFormat#ENCODING_PCM_8BIT}
+* @return {@link #ERROR_BAD_VALUE} if an invalid parameter was passed,
+* or {@link #ERROR} if unable to query for output properties,
+* or the minimum buffer size expressed in bytes.
+*/
     static public int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat) {
         int channelCount = 0;
         switch(channelConfig) {
@@ -702,7 +702,8 @@ public class AudioTrack
         }
 
         if ((audioFormat != AudioFormat.ENCODING_PCM_16BIT)
-            && (audioFormat != AudioFormat.ENCODING_PCM_8BIT)) {
+            && (audioFormat != AudioFormat.ENCODING_PCM_8BIT)
+            && (audioFormat != AudioFormat.ENCODING_PCM_24BIT)) {
             loge("getMinBufferSize(): Invalid audio format.");
             return ERROR_BAD_VALUE;
         }
@@ -724,36 +725,36 @@ public class AudioTrack
     }
 
     /**
-     * Returns the audio session ID.
-     *
-     * @return the ID of the audio session this AudioTrack belongs to.
-     */
+* Returns the audio session ID.
+*
+* @return the ID of the audio session this AudioTrack belongs to.
+*/
     public int getAudioSessionId() {
         return mSessionId;
     }
 
    /**
-    * Poll for a timestamp on demand.
-    *
-    * Use if you need to get the most recent timestamp outside of the event callback handler.
-    * Calling this method too often may be inefficient;
-    * if you need a high-resolution mapping between frame position and presentation time,
-    * consider implementing that at application level, based on low-resolution timestamps.
-    * The audio data at the returned position may either already have been
-    * presented, or may have not yet been presented but is committed to be presented.
-    * It is not possible to request the time corresponding to a particular position,
-    * or to request the (fractional) position corresponding to a particular time.
-    * If you need such features, consider implementing them at application level.
-    *
-    * @param timestamp a reference to a non-null AudioTimestamp instance allocated
-    *        and owned by caller.
-    * @return true if a timestamp is available, or false if no timestamp is available.
-    *         If a timestamp if available,
-    *         the AudioTimestamp instance is filled in with a position in frame units, together
-    *         with the estimated time when that frame was presented or is committed to
-    *         be presented.
-    *         In the case that no timestamp is available, any supplied instance is left unaltered.
-    */
+* Poll for a timestamp on demand.
+*
+* Use if you need to get the most recent timestamp outside of the event callback handler.
+* Calling this method too often may be inefficient;
+* if you need a high-resolution mapping between frame position and presentation time,
+* consider implementing that at application level, based on low-resolution timestamps.
+* The audio data at the returned position may either already have been
+* presented, or may have not yet been presented but is committed to be presented.
+* It is not possible to request the time corresponding to a particular position,
+* or to request the (fractional) position corresponding to a particular time.
+* If you need such features, consider implementing them at application level.
+*
+* @param timestamp a reference to a non-null AudioTimestamp instance allocated
+* and owned by caller.
+* @return true if a timestamp is available, or false if no timestamp is available.
+* If a timestamp if available,
+* the AudioTimestamp instance is filled in with a position in frame units, together
+* with the estimated time when that frame was presented or is committed to
+* be presented.
+* In the case that no timestamp is available, any supplied instance is left unaltered.
+*/
     public boolean getTimestamp(AudioTimestamp timestamp)
     {
         if (timestamp == null) {
@@ -775,24 +776,24 @@ public class AudioTrack
     // Initialization / configuration
     //--------------------
     /**
-     * Sets the listener the AudioTrack notifies when a previously set marker is reached or
-     * for each periodic playback head position update.
-     * Notifications will be received in the same thread as the one in which the AudioTrack
-     * instance was created.
-     * @param listener
-     */
+* Sets the listener the AudioTrack notifies when a previously set marker is reached or
+* for each periodic playback head position update.
+* Notifications will be received in the same thread as the one in which the AudioTrack
+* instance was created.
+* @param listener
+*/
     public void setPlaybackPositionUpdateListener(OnPlaybackPositionUpdateListener listener) {
         setPlaybackPositionUpdateListener(listener, null);
     }
 
     /**
-     * Sets the listener the AudioTrack notifies when a previously set marker is reached or
-     * for each periodic playback head position update.
-     * Use this method to receive AudioTrack events in the Handler associated with another
-     * thread than the one in which you created the AudioTrack instance.
-     * @param listener
-     * @param handler the Handler that will receive the event notification messages.
-     */
+* Sets the listener the AudioTrack notifies when a previously set marker is reached or
+* for each periodic playback head position update.
+* Use this method to receive AudioTrack events in the Handler associated with another
+* thread than the one in which you created the AudioTrack instance.
+* @param listener
+* @param handler the Handler that will receive the event notification messages.
+*/
     public void setPlaybackPositionUpdateListener(OnPlaybackPositionUpdateListener listener,
                                                     Handler handler) {
         if (listener != null) {
@@ -805,14 +806,14 @@ public class AudioTrack
 
 
      /**
-     * Sets the specified left/right output volume values on the AudioTrack. Values are clamped
-     * to the ({@link #getMinVolume()}, {@link #getMaxVolume()}) interval if outside this range.
-     * @param leftVolume output attenuation for the left channel. A value of 0.0f is silence,
-     *      a value of 1.0f is no attenuation.
-     * @param rightVolume output attenuation for the right channel
-     * @return error code or success, see {@link #SUCCESS},
-     *    {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the specified left/right output volume values on the AudioTrack. Values are clamped
+* to the ({@link #getMinVolume()}, {@link #getMaxVolume()}) interval if outside this range.
+* @param leftVolume output attenuation for the left channel. A value of 0.0f is silence,
+* a value of 1.0f is no attenuation.
+* @param rightVolume output attenuation for the right channel
+* @return error code or success, see {@link #SUCCESS},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setStereoVolume(float leftVolume, float rightVolume) {
         if (mState == STATE_UNINITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -839,28 +840,28 @@ public class AudioTrack
 
 
     /**
-     * Similar, except set volume of all channels to same value.
-     * @hide
-     */
+* Similar, except set volume of all channels to same value.
+* @hide
+*/
     public int setVolume(float volume) {
         return setStereoVolume(volume, volume);
     }
 
 
     /**
-     * Sets the playback sample rate for this track. This sets the sampling rate at which
-     * the audio data will be consumed and played back
-     * (as set by the sampleRateInHz parameter in the
-     * {@link #AudioTrack(int, int, int, int, int, int)} constructor),
-     * not the original sampling rate of the
-     * content. For example, setting it to half the sample rate of the content will cause the
-     * playback to last twice as long, but will also result in a pitch shift down by one octave.
-     * The valid sample rate range is from 1 Hz to twice the value returned by
-     * {@link #getNativeOutputSampleRate(int)}.
-     * @param sampleRateInHz the sample rate expressed in Hz
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
-     *    {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the playback sample rate for this track. This sets the sampling rate at which
+* the audio data will be consumed and played back
+* (as set by the sampleRateInHz parameter in the
+* {@link #AudioTrack(int, int, int, int, int, int)} constructor),
+* not the original sampling rate of the
+* content. For example, setting it to half the sample rate of the content will cause the
+* playback to last twice as long, but will also result in a pitch shift down by one octave.
+* The valid sample rate range is from 1 Hz to twice the value returned by
+* {@link #getNativeOutputSampleRate(int)}.
+* @param sampleRateInHz the sample rate expressed in Hz
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setPlaybackRate(int sampleRateInHz) {
         if (mState != STATE_INITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -873,14 +874,14 @@ public class AudioTrack
 
 
     /**
-     * Sets the position of the notification marker.  At most one marker can be active.
-     * @param markerInFrames marker position in wrapping frame units similar to
-     * {@link #getPlaybackHeadPosition}, or zero to disable the marker.
-     * To set a marker at a position which would appear as zero due to wraparound,
-     * a workaround is to use a non-zero position near zero, such as -1 or 1.
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
-     *  {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the position of the notification marker. At most one marker can be active.
+* @param markerInFrames marker position in wrapping frame units similar to
+* {@link #getPlaybackHeadPosition}, or zero to disable the marker.
+* To set a marker at a position which would appear as zero due to wraparound,
+* a workaround is to use a non-zero position near zero, such as -1 or 1.
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setNotificationMarkerPosition(int markerInFrames) {
         if (mState == STATE_UNINITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -890,10 +891,10 @@ public class AudioTrack
 
 
     /**
-     * Sets the period for the periodic notification event.
-     * @param periodInFrames update period expressed in frames
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the period for the periodic notification event.
+* @param periodInFrames update period expressed in frames
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_INVALID_OPERATION}
+*/
     public int setPositionNotificationPeriod(int periodInFrames) {
         if (mState == STATE_UNINITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -903,15 +904,15 @@ public class AudioTrack
 
 
     /**
-     * Sets the playback head position.
-     * The track must be stopped or paused for the position to be changed,
-     * and must use the {@link #MODE_STATIC} mode.
-     * @param positionInFrames playback head position expressed in frames
-     * Zero corresponds to start of buffer.
-     * The position must not be greater than the buffer size in frames, or negative.
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
-     *    {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the playback head position.
+* The track must be stopped or paused for the position to be changed,
+* and must use the {@link #MODE_STATIC} mode.
+* @param positionInFrames playback head position expressed in frames
+* Zero corresponds to start of buffer.
+* The position must not be greater than the buffer size in frames, or negative.
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setPlaybackHeadPosition(int positionInFrames) {
         if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED ||
                 getPlayState() == PLAYSTATE_PLAYING) {
@@ -924,31 +925,31 @@ public class AudioTrack
     }
 
     /**
-     * Sets the loop points and the loop count. The loop can be infinite.
-     * Similarly to setPlaybackHeadPosition,
-     * the track must be stopped or paused for the loop points to be changed,
-     * and must use the {@link #MODE_STATIC} mode.
-     * @param startInFrames loop start marker expressed in frames
-     * Zero corresponds to start of buffer.
-     * The start marker must not be greater than or equal to the buffer size in frames, or negative.
-     * @param endInFrames loop end marker expressed in frames
-     * The total buffer size in frames corresponds to end of buffer.
-     * The end marker must not be greater than the buffer size in frames.
-     * For looping, the end marker must not be less than or equal to the start marker,
-     * but to disable looping
-     * it is permitted for start marker, end marker, and loop count to all be 0.
-     * @param loopCount the number of times the loop is looped.
-     *    A value of -1 means infinite looping, and 0 disables looping.
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
-     *    {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the loop points and the loop count. The loop can be infinite.
+* Similarly to setPlaybackHeadPosition,
+* the track must be stopped or paused for the loop points to be changed,
+* and must use the {@link #MODE_STATIC} mode.
+* @param startInFrames loop start marker expressed in frames
+* Zero corresponds to start of buffer.
+* The start marker must not be greater than or equal to the buffer size in frames, or negative.
+* @param endInFrames loop end marker expressed in frames
+* The total buffer size in frames corresponds to end of buffer.
+* The end marker must not be greater than the buffer size in frames.
+* For looping, the end marker must not be less than or equal to the start marker,
+* but to disable looping
+* it is permitted for start marker, end marker, and loop count to all be 0.
+* @param loopCount the number of times the loop is looped.
+* A value of -1 means infinite looping, and 0 disables looping.
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setLoopPoints(int startInFrames, int endInFrames, int loopCount) {
         if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED ||
                 getPlayState() == PLAYSTATE_PLAYING) {
             return ERROR_INVALID_OPERATION;
         }
         if (loopCount == 0) {
-            ;   // explicitly allowed as an exception to the loop region range check
+            ; // explicitly allowed as an exception to the loop region range check
         } else if (!(0 <= startInFrames && startInFrames < mNativeBufferSizeInFrames &&
                 startInFrames < endInFrames && endInFrames <= mNativeBufferSizeInFrames)) {
             return ERROR_BAD_VALUE;
@@ -957,12 +958,12 @@ public class AudioTrack
     }
 
     /**
-     * Sets the initialization state of the instance. This method was originally intended to be used
-     * in an AudioTrack subclass constructor to set a subclass-specific post-initialization state.
-     * However, subclasses of AudioTrack are no longer recommended, so this method is obsolete.
-     * @param state the state of the AudioTrack instance
-     * @deprecated Only accessible by subclasses, which are not recommended for AudioTrack.
-     */
+* Sets the initialization state of the instance. This method was originally intended to be used
+* in an AudioTrack subclass constructor to set a subclass-specific post-initialization state.
+* However, subclasses of AudioTrack are no longer recommended, so this method is obsolete.
+* @param state the state of the AudioTrack instance
+* @deprecated Only accessible by subclasses, which are not recommended for AudioTrack.
+*/
     @Deprecated
     protected void setState(int state) {
         mState = state;
@@ -973,11 +974,11 @@ public class AudioTrack
     // Transport control methods
     //--------------------
     /**
-     * Starts playing an AudioTrack.
-     * If track's creation mode is {@link #MODE_STATIC}, you must have called write() prior.
-     *
-     * @throws IllegalStateException
-     */
+* Starts playing an AudioTrack.
+* If track's creation mode is {@link #MODE_STATIC}, you must have called write() prior.
+*
+* @throws IllegalStateException
+*/
     public void play()
     throws IllegalStateException {
         if (mState != STATE_INITIALIZED) {
@@ -991,13 +992,13 @@ public class AudioTrack
     }
 
     /**
-     * Stops playing the audio data.
-     * When used on an instance created in {@link #MODE_STREAM} mode, audio will stop playing
-     * after the last buffer that was written has been played. For an immediate stop, use
-     * {@link #pause()}, followed by {@link #flush()} to discard audio data that hasn't been played
-     * back yet.
-     * @throws IllegalStateException
-     */
+* Stops playing the audio data.
+* When used on an instance created in {@link #MODE_STREAM} mode, audio will stop playing
+* after the last buffer that was written has been played. For an immediate stop, use
+* {@link #pause()}, followed by {@link #flush()} to discard audio data that hasn't been played
+* back yet.
+* @throws IllegalStateException
+*/
     public void stop()
     throws IllegalStateException {
         if (mState != STATE_INITIALIZED) {
@@ -1012,12 +1013,12 @@ public class AudioTrack
     }
 
     /**
-     * Pauses the playback of the audio data. Data that has not been played
-     * back will not be discarded. Subsequent calls to {@link #play} will play
-     * this data back. See {@link #flush()} to discard this data.
-     *
-     * @throws IllegalStateException
-     */
+* Pauses the playback of the audio data. Data that has not been played
+* back will not be discarded. Subsequent calls to {@link #play} will play
+* this data back. See {@link #flush()} to discard this data.
+*
+* @throws IllegalStateException
+*/
     public void pause()
     throws IllegalStateException {
         if (mState != STATE_INITIALIZED) {
@@ -1038,10 +1039,10 @@ public class AudioTrack
     //--------------------
 
     /**
-     * Flushes the audio data currently queued for playback. Any data that has
-     * not been played back will be discarded.  No-op if not stopped or paused,
-     * or if the track's creation mode is not {@link #MODE_STREAM}.
-     */
+* Flushes the audio data currently queued for playback. Any data that has
+* not been played back will be discarded. No-op if not stopped or paused,
+* or if the track's creation mode is not {@link #MODE_STREAM}.
+*/
     public void flush() {
         if (mState == STATE_INITIALIZED) {
             // flush the data in native layer
@@ -1051,22 +1052,22 @@ public class AudioTrack
     }
 
     /**
-     * Writes the audio data to the audio sink for playback (streaming mode),
-     * or copies audio data for later playback (static buffer mode).
-     * In streaming mode, will block until all data has been written to the audio sink.
-     * In static buffer mode, copies the data to the buffer starting at offset 0.
-     * Note that the actual playback of this data might occur after this function
-     * returns. This function is thread safe with respect to {@link #stop} calls,
-     * in which case all of the specified data might not be written to the audio sink.
-     *
-     * @param audioData the array that holds the data to play.
-     * @param offsetInBytes the offset expressed in bytes in audioData where the data to play
-     *    starts.
-     * @param sizeInBytes the number of bytes to read in audioData after the offset.
-     * @return the number of bytes that were written or {@link #ERROR_INVALID_OPERATION}
-     *    if the object wasn't properly initialized, or {@link #ERROR_BAD_VALUE} if
-     *    the parameters don't resolve to valid data and indexes.
-     */
+* Writes the audio data to the audio sink for playback (streaming mode),
+* or copies audio data for later playback (static buffer mode).
+* In streaming mode, will block until all data has been written to the audio sink.
+* In static buffer mode, copies the data to the buffer starting at offset 0.
+* Note that the actual playback of this data might occur after this function
+* returns. This function is thread safe with respect to {@link #stop} calls,
+* in which case all of the specified data might not be written to the audio sink.
+*
+* @param audioData the array that holds the data to play.
+* @param offsetInBytes the offset expressed in bytes in audioData where the data to play
+* starts.
+* @param sizeInBytes the number of bytes to read in audioData after the offset.
+* @return the number of bytes that were written or {@link #ERROR_INVALID_OPERATION}
+* if the object wasn't properly initialized, or {@link #ERROR_BAD_VALUE} if
+* the parameters don't resolve to valid data and indexes.
+*/
 
     public int write(byte[] audioData, int offsetInBytes, int sizeInBytes) {
 
@@ -1075,7 +1076,7 @@ public class AudioTrack
         }
 
         if ( (audioData == null) || (offsetInBytes < 0 ) || (sizeInBytes < 0)
-                || (offsetInBytes + sizeInBytes < 0)    // detect integer overflow
+                || (offsetInBytes + sizeInBytes < 0) // detect integer overflow
                 || (offsetInBytes + sizeInBytes > audioData.length)) {
             return ERROR_BAD_VALUE;
         }
@@ -1094,22 +1095,22 @@ public class AudioTrack
 
 
     /**
-     * Writes the audio data to the audio sink for playback (streaming mode),
-     * or copies audio data for later playback (static buffer mode).
-     * In streaming mode, will block until all data has been written to the audio sink.
-     * In static buffer mode, copies the data to the buffer starting at offset 0.
-     * Note that the actual playback of this data might occur after this function
-     * returns. This function is thread safe with respect to {@link #stop} calls,
-     * in which case all of the specified data might not be written to the audio sink.
-     *
-     * @param audioData the array that holds the data to play.
-     * @param offsetInShorts the offset expressed in shorts in audioData where the data to play
-     *     starts.
-     * @param sizeInShorts the number of shorts to read in audioData after the offset.
-     * @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}
-      *    if the object wasn't properly initialized, or {@link #ERROR_BAD_VALUE} if
-      *    the parameters don't resolve to valid data and indexes.
-     */
+* Writes the audio data to the audio sink for playback (streaming mode),
+* or copies audio data for later playback (static buffer mode).
+* In streaming mode, will block until all data has been written to the audio sink.
+* In static buffer mode, copies the data to the buffer starting at offset 0.
+* Note that the actual playback of this data might occur after this function
+* returns. This function is thread safe with respect to {@link #stop} calls,
+* in which case all of the specified data might not be written to the audio sink.
+*
+* @param audioData the array that holds the data to play.
+* @param offsetInShorts the offset expressed in shorts in audioData where the data to play
+* starts.
+* @param sizeInShorts the number of shorts to read in audioData after the offset.
+* @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}
+* if the object wasn't properly initialized, or {@link #ERROR_BAD_VALUE} if
+* the parameters don't resolve to valid data and indexes.
+*/
 
     public int write(short[] audioData, int offsetInShorts, int sizeInShorts) {
 
@@ -1118,7 +1119,7 @@ public class AudioTrack
         }
 
         if ( (audioData == null) || (offsetInShorts < 0 ) || (sizeInShorts < 0)
-                || (offsetInShorts + sizeInShorts < 0)  // detect integer overflow
+                || (offsetInShorts + sizeInShorts < 0) // detect integer overflow
                 || (offsetInShorts + sizeInShorts > audioData.length)) {
             return ERROR_BAD_VALUE;
         }
@@ -1137,12 +1138,12 @@ public class AudioTrack
 
 
     /**
-     * Notifies the native resource to reuse the audio data already loaded in the native
-     * layer, that is to rewind to start of buffer.
-     * The track's creation mode must be {@link #MODE_STATIC}.
-     * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
-     *  {@link #ERROR_INVALID_OPERATION}
-     */
+* Notifies the native resource to reuse the audio data already loaded in the native
+* layer, that is to rewind to start of buffer.
+* The track's creation mode must be {@link #MODE_STATIC}.
+* @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int reloadStaticData() {
         if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -1155,22 +1156,22 @@ public class AudioTrack
     //--------------------
 
     /**
-     * Attaches an auxiliary effect to the audio track. A typical auxiliary
-     * effect is a reverberation effect which can be applied on any sound source
-     * that directs a certain amount of its energy to this effect. This amount
-     * is defined by setAuxEffectSendLevel().
-     * {@see #setAuxEffectSendLevel(float)}.
-     * <p>After creating an auxiliary effect (e.g.
-     * {@link android.media.audiofx.EnvironmentalReverb}), retrieve its ID with
-     * {@link android.media.audiofx.AudioEffect#getId()} and use it when calling
-     * this method to attach the audio track to the effect.
-     * <p>To detach the effect from the audio track, call this method with a
-     * null effect id.
-     *
-     * @param effectId system wide unique id of the effect to attach
-     * @return error code or success, see {@link #SUCCESS},
-     *    {@link #ERROR_INVALID_OPERATION}, {@link #ERROR_BAD_VALUE}
-     */
+* Attaches an auxiliary effect to the audio track. A typical auxiliary
+* effect is a reverberation effect which can be applied on any sound source
+* that directs a certain amount of its energy to this effect. This amount
+* is defined by setAuxEffectSendLevel().
+* {@see #setAuxEffectSendLevel(float)}.
+* <p>After creating an auxiliary effect (e.g.
+* {@link android.media.audiofx.EnvironmentalReverb}), retrieve its ID with
+* {@link android.media.audiofx.AudioEffect#getId()} and use it when calling
+* this method to attach the audio track to the effect.
+* <p>To detach the effect from the audio track, call this method with a
+* null effect id.
+*
+* @param effectId system wide unique id of the effect to attach
+* @return error code or success, see {@link #SUCCESS},
+* {@link #ERROR_INVALID_OPERATION}, {@link #ERROR_BAD_VALUE}
+*/
     public int attachAuxEffect(int effectId) {
         if (mState == STATE_UNINITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -1179,21 +1180,21 @@ public class AudioTrack
     }
 
     /**
-     * Sets the send level of the audio track to the attached auxiliary effect
-     * {@link #attachAuxEffect(int)}.  The level value range is 0.0f to 1.0f.
-     * Values are clamped to the (0.0f, 1.0f) interval if outside this range.
-     * <p>By default the send level is 0.0f, so even if an effect is attached to the player
-     * this method must be called for the effect to be applied.
-     * <p>Note that the passed level value is a raw scalar. UI controls should be scaled
-     * logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
-     * so an appropriate conversion from linear UI input x to level is:
-     * x == 0 -&gt; level = 0
-     * 0 &lt; x &lt;= R -&gt; level = 10^(72*(x-R)/20/R)
-     *
-     * @param level send level scalar
-     * @return error code or success, see {@link #SUCCESS},
-     *    {@link #ERROR_INVALID_OPERATION}
-     */
+* Sets the send level of the audio track to the attached auxiliary effect
+* {@link #attachAuxEffect(int)}. The level value range is 0.0f to 1.0f.
+* Values are clamped to the (0.0f, 1.0f) interval if outside this range.
+* <p>By default the send level is 0.0f, so even if an effect is attached to the player
+* this method must be called for the effect to be applied.
+* <p>Note that the passed level value is a raw scalar. UI controls should be scaled
+* logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
+* so an appropriate conversion from linear UI input x to level is:
+* x == 0 -&gt; level = 0
+* 0 &lt; x &lt;= R -&gt; level = 10^(72*(x-R)/20/R)
+*
+* @param level send level scalar
+* @return error code or success, see {@link #SUCCESS},
+* {@link #ERROR_INVALID_OPERATION}
+*/
     public int setAuxEffectSendLevel(float level) {
         if (mState == STATE_UNINITIALIZED) {
             return ERROR_INVALID_OPERATION;
@@ -1213,20 +1214,20 @@ public class AudioTrack
     // Interface definitions
     //--------------------
     /**
-     * Interface definition for a callback to be invoked when the playback head position of
-     * an AudioTrack has reached a notification marker or has increased by a certain period.
-     */
-    public interface OnPlaybackPositionUpdateListener  {
+* Interface definition for a callback to be invoked when the playback head position of
+* an AudioTrack has reached a notification marker or has increased by a certain period.
+*/
+    public interface OnPlaybackPositionUpdateListener {
         /**
-         * Called on the listener to notify it that the previously set marker has been reached
-         * by the playback head.
-         */
+* Called on the listener to notify it that the previously set marker has been reached
+* by the playback head.
+*/
         void onMarkerReached(AudioTrack track);
 
         /**
-         * Called on the listener to periodically notify it that the playback head has reached
-         * a multiple of the notification period.
-         */
+* Called on the listener to periodically notify it that the playback head has reached
+* a multiple of the notification period.
+*/
         void onPeriodicNotification(AudioTrack track);
     }
 
@@ -1235,9 +1236,9 @@ public class AudioTrack
     // Inner classes
     //--------------------
     /**
-     * Helper class to handle the forwarding of native events to the appropriate listener
-     * (potentially) handled in a different thread
-     */
+* Helper class to handle the forwarding of native events to the appropriate listener
+* (potentially) handled in a different thread
+*/
     private class NativeEventHandlerDelegate {
         private final Handler mHandler;
 
diff --git a/services/java/com/android/server/WiredAccessoryManager.java b/services/java/com/android/server/WiredAccessoryManager.java
index 415fcc1..b6e3b35 100644
--- a/services/java/com/android/server/WiredAccessoryManager.java
+++ b/services/java/com/android/server/WiredAccessoryManager.java
@@ -45,6 +45,7 @@ import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
+import android.os.SystemProperties;
 
 /**
  * <p>WiredAccessoryManager monitors for a wired headset on the main board or dock using
@@ -80,11 +81,18 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
     private int mSwitchValues;
 
+    private boolean dockAudioEnabled = false;
+
     private final WiredAccessoryObserver mObserver;
     private final InputManagerService mInputManager;
 
     private final boolean mUseDevInputEventForAudioJack;
 
+    // tmtmtm
+    private final Context mContext;
+    private static final String ALSA_ID = "116";
+    private String activeAlsaOutputDevice = null;
+
     public WiredAccessoryManager(Context context, InputManagerService inputManager) {
         PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
         mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "WiredAccessoryManager");
@@ -97,6 +105,17 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         mObserver = new WiredAccessoryObserver();
 
+        // tmtmtm
+        mContext = context;
+        //if (LOG) Slog.v(TAG, "init() startObserving="+ALSA_ID);
+        //mObserver.startObserving("MAJOR="+ALSA_ID);
+
+        File f = new File("/sys/class/switch/dock/state");
+        if (f!=null && f.exists()) {
+            // Listen out for changes to the Dock Audio Settings
+            context.registerReceiver(new SettingsChangedReceiver(),
+            new IntentFilter("com.cyanogenmod.settings.SamsungDock"), null, null);
+        }
         context.registerReceiver(new BroadcastReceiver() {
                     @Override
                     public void onReceive(Context ctx, Intent intent) {
@@ -106,8 +125,27 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 new IntentFilter(Intent.ACTION_BOOT_COMPLETED), null, null);
     }
 
+    private final class SettingsChangedReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            Slog.e(TAG, "Recieved a Settings Changed Action " + action);
+            if (action.equals("com.cyanogenmod.settings.SamsungDock")) {
+                String data = intent.getStringExtra("data");
+                Slog.e(TAG, "Recieved a Dock Audio change " + data);
+                if (data != null && data.equals("1")) {
+                    dockAudioEnabled = true;
+                } else {
+                    dockAudioEnabled = false;
+                }
+            }
+        }
+    }
+
     private void bootCompleted() {
+        if (LOG) Slog.v(TAG, "bootCompleted()");
         if (mUseDevInputEventForAudioJack) {
+            if (LOG) Slog.v(TAG, "bootCompleted() mUseDevInputEventForAudioJack");
             int switchValues = 0;
             if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_HEADPHONE_INSERT) == 1) {
                 switchValues |= SW_HEADPHONE_INSERT_BIT;
@@ -216,6 +254,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         public void handleMessage(Message msg) {
             switch (msg.what) {
                 case MSG_NEW_DEVICE_STATE:
+                    if (LOG) Slog.v(TAG, "MSG_NEW_DEVICE_STATE arg1="+msg.arg1+" arg2="+msg.arg2);
                     setDevicesState(msg.arg1, msg.arg2, (String)msg.obj);
                     mWakeLock.release();
             }
@@ -224,6 +263,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
     private void setDevicesState(
             int headsetState, int prevHeadsetState, String headsetName) {
+        if (LOG) Slog.v(TAG, "setDevicesState headsetState="+headsetState+" prevHeadsetState="+prevHeadsetState+" headsetName="+headsetName);
         synchronized (mLock) {
             int allHeadsets = SUPPORTED_HEADSETS;
             for (int curHeadset = 1; allHeadsets != 0; curHeadset <<= 1) {
@@ -301,7 +341,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                         FileReader file = new FileReader(uei.getSwitchStatePath());
                         int len = file.read(buffer, 0, 1024);
                         file.close();
-                        curState = Integer.valueOf((new String(buffer, 0, len)).trim());
+                        curState = validateSwitchState(
+                                Integer.valueOf((new String(buffer, 0, len)).trim()));
 
                         if (curState > 0) {
                             updateStateLocked(uei.getDevPath(), uei.getDevName(), curState);
@@ -315,13 +356,29 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 }
             }
 
+            if (LOG) Slog.v(TAG, "init() observe all UEVENTs");
             // At any given time accessories could be inserted
-            // one on the board, one on the dock and one on HDMI:
-            // observe three UEVENTs
+            // one on the board, one on the dock, one on the
+            // samsung dock and one on HDMI:
+            // observe all UEVENTs that have valid switch supported
+            // by the Kernel
             for (int i = 0; i < mUEventInfo.size(); ++i) {
                 UEventInfo uei = mUEventInfo.get(i);
+                if (LOG) Slog.v(TAG, "init() startObserving="+uei.getDevPath());
                 startObserving("DEVPATH="+uei.getDevPath());
             }
+
+	        // tmtmtm
+            if (LOG) Slog.v(TAG, "init() startObserving="+ALSA_ID);
+            activeAlsaOutputDevice = null;
+	        mObserver.startObserving("MAJOR="+ALSA_ID);
+        }
+
+        private int validateSwitchState(int state) {
+            // Some drivers, namely HTC headset ones, add additional bits to
+            // the switch state. As we only are able to deal with the states
+            // 0, 1 and 2, mask out all the other bits
+            return state & 0x3;
         }
 
         private List<UEventInfo> makeObservedUEventList() {
@@ -341,11 +398,20 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             // Monitor USB
             uei = new UEventInfo(NAME_USB_AUDIO, BIT_USB_HEADSET_ANLG, BIT_USB_HEADSET_DGTL);
             if (uei.checkSwitchExists()) {
+                Slog.i(TAG, "This kernel has usb audio support");
                 retVal.add(uei);
             } else {
                 Slog.w(TAG, "This kernel does not have usb audio support");
             }
 
+            // Monitor Samsung USB audio
+            uei = new UEventInfo("dock", BIT_USB_HEADSET_DGTL, BIT_USB_HEADSET_ANLG);
+            if (uei.checkSwitchExists()) {
+                retVal.add(uei);
+            } else {
+                Slog.w(TAG, "This kernel does not have samsung usb dock audio support");
+            }
+
             // Monitor HDMI
             //
             // If the kernel has support for the "hdmi_audio" switch, use that.  It will be
@@ -371,12 +437,72 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         @Override
         public void onUEvent(UEventObserver.UEvent event) {
-            if (LOG) Slog.v(TAG, "Headset UEVENT: " + event.toString());
+            //if (LOG) Slog.v(TAG, "Headset UEVENT: " + event.toString());
+
+            // tmtmtm: handle UEvent containing ALSA usb audio device; based on code by jacknorris
+            String major = event.get("MAJOR");
+            String devname = event.get("DEVNAME");
+            if (major!=null && major.equals(ALSA_ID)) {
+                final String USE_HP_WIRED_ACCESSORY_PERSIST_PROP = "persist.sys.use_wired_accessory";
+                final String USE_HP_WIRED_ACCESSORY_DEFAULT = "1";
+                String useHpWiredAccessory = SystemProperties.get(USE_HP_WIRED_ACCESSORY_PERSIST_PROP,
+                                                                  USE_HP_WIRED_ACCESSORY_DEFAULT);
+                if("1".equals(useHpWiredAccessory)) {
+                    String devpath = event.get("DEVPATH").toLowerCase();
+                  //if(LOG) Slog.i(TAG, "#### onUEvent ALSA_ID name="+devname+" devpath="+devpath);
+                    if(LOG) Slog.i(TAG, "#### onUEvent ALSA_ID name="+devname+" action="+event.get("ACTION"));
+                    if (devpath.contains("usb") && !devpath.contains("gadget") && devname.endsWith("p")) {
+                    	boolean actionAdd = event.get("ACTION").equals("add");
+/*
+				        final String HP_WIRED_ACCESSORY_PREF_DEV_PROP = "persist.sys.wired_acc_pref_dev";
+				        final String HP_WIRED_ACCESSORY_PREF_DEV_DEFAULT = "#";
+				        String hpWiredAccessoryPrefDev = SystemProperties.get(HP_WIRED_ACCESSORY_PREF_DEV_PROP,
+				                                                              HP_WIRED_ACCESSORY_PREF_DEV_DEFAULT);
+                    	if(!actionAdd || activeAlsaOutputDevice==null || //hpWiredAccessoryPrefDev.length()<1 || 
+	                   	    	devname.endsWith(hpWiredAccessoryPrefDev+"p")) {
+*/
+		                    try {
+		                        if (LOG) Slog.i(TAG, "#### broadcast AUDIO_BECOMING_NOISY + USB_AUDIO_DEVICE_PLUG");
+		                        mContext.sendBroadcast(new Intent("android.media.AUDIO_BECOMING_NOISY"));
+		                        final Intent usbAudio = new Intent("android.intent.action.USB_AUDIO_DEVICE_PLUG");
+		                        usbAudio.putExtra("state", actionAdd?1:0);
+		                        usbAudio.putExtra("card", Integer.parseInt(""+devname.charAt(8)));
+		                        usbAudio.putExtra("device", Integer.parseInt(""+devname.charAt(10)));
+		                        usbAudio.putExtra("channels", 2);
+//		                        mContext.sendStickyBroadcast(usbAudio);
+		                        mContext.sendBroadcast(usbAudio);
+/*
+		                        if(actionAdd) {
+		                        	activeAlsaOutputDevice = devname;
+		                        } else if(devname.equals(activeAlsaOutputDevice)) {
+		                        	activeAlsaOutputDevice  = null;
+		                        } 
+*/
+		                    } catch (Exception ex) {
+		                        Slog.e(TAG, "Could not broadcast USB_AUDIO_DEVICE_PLUG " + ex);
+		                    }
+/*
+		                }
+*/
+                    }
+                }
+                return;
+            }
 
+            int state = validateSwitchState(Integer.parseInt(event.get("SWITCH_STATE")));
             try {
                 String devPath = event.get("DEVPATH");
                 String name = event.get("SWITCH_NAME");
-                int state = Integer.parseInt(event.get("SWITCH_STATE"));
+                if (name.equals("dock")) {
+                    // Samsung USB Audio Jack is non-sensing - so must be enabled manually
+                    // The choice is made in the GalaxyS2Settings.apk
+                    // device/samsung/i9100/DeviceSettings/src/com/cyanogenmod/settings/device/DockFragmentActivity.java
+                    // This sends an Intent to this class
+                    if ((!dockAudioEnabled) && (state > 0)) {
+                        Slog.e(TAG, "Ignoring dock event as Audio routing disabled " + event);
+                        return;
+                    }
+                }
                 synchronized (mLock) {
                     updateStateLocked(devPath, name, state);
                 }
-- 
1.8.3.2

